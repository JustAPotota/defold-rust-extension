/* automatically generated by rust-bindgen 0.69.4 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[repr(C)]
    #[derive(Default)]
    pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
    impl<T> __IncompleteArrayField<T> {
        #[inline]
        pub const fn new() -> Self {
            __IncompleteArrayField(::std::marker::PhantomData, [])
        }
        #[inline]
        pub fn as_ptr(&self) -> *const T {
            self as *const _ as *const T
        }
        #[inline]
        pub fn as_mut_ptr(&mut self) -> *mut T {
            self as *mut _ as *mut T
        }
        #[inline]
        pub unsafe fn as_slice(&self, len: usize) -> &[T] {
            ::std::slice::from_raw_parts(self.as_ptr(), len)
        }
        #[inline]
        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
            ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
        }
    }
    impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__IncompleteArrayField")
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const DM_HASH_FMT: &[u8; 7] = b"%016lx\0";
    pub const LUA_PATH: &[u8; 9] = b"LUA_PATH\0";
    pub const LUA_CPATH: &[u8; 10] = b"LUA_CPATH\0";
    pub const LUA_INIT: &[u8; 9] = b"LUA_INIT\0";
    pub const LUA_ROOT: &[u8; 12] = b"/usr/local/\0";
    pub const LUA_LDIR: &[u8; 26] = b"/usr/local/share/lua/5.1/\0";
    pub const LUA_CDIR: &[u8; 24] = b"/usr/local/lib/lua/5.1/\0";
    pub const LUA_PATH_DEFAULT : & [u8 ; 138] = b"./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua\0" ;
    pub const LUA_CPATH_DEFAULT: &[u8; 69] =
        b"./?.so;/usr/local/lib/lua/5.1/?.so;/usr/local/lib/lua/5.1/loadall.so\0";
    pub const LUA_DIRSEP: &[u8; 2] = b"/\0";
    pub const LUA_PATHSEP: &[u8; 2] = b";\0";
    pub const LUA_PATH_MARK: &[u8; 2] = b"?\0";
    pub const LUA_EXECDIR: &[u8; 2] = b"!\0";
    pub const LUA_IGMARK: &[u8; 2] = b"-\0";
    pub const LUA_IDSIZE: u32 = 60;
    pub const LUAI_GCPAUSE: u32 = 200;
    pub const LUAI_GCMUL: u32 = 200;
    pub const LUA_COMPAT_LSTR: u32 = 1;
    pub const LUAI_BITSINT: u32 = 32;
    pub const LUAI_MAXCALLS: u32 = 20000;
    pub const LUAI_MAXCSTACK: u32 = 8000;
    pub const LUAI_MAXCCALLS: u32 = 200;
    pub const LUAI_MAXVARS: u32 = 200;
    pub const LUAI_MAXUPVALUES: u32 = 60;
    pub const LUA_NUMBER_SCAN: &[u8; 4] = b"%lf\0";
    pub const LUA_NUMBER_FMT: &[u8; 6] = b"%.14g\0";
    pub const LUAI_MAXNUMBER2STR: u32 = 32;
    pub const LUA_MAXCAPTURES: u32 = 32;
    pub const LUAI_EXTRASPACE: u32 = 0;
    pub const LUA_INTFRMLEN: &[u8; 2] = b"l\0";
    pub const LUA_VERSION: &[u8; 8] = b"Lua 5.1\0";
    pub const LUA_RELEASE: &[u8; 10] = b"Lua 5.1.4\0";
    pub const LUA_VERSION_NUM: u32 = 501;
    pub const LUA_COPYRIGHT: &[u8; 41] = b"Copyright (C) 1994-2008 Lua.org, PUC-Rio\0";
    pub const LUA_AUTHORS: &[u8; 49] = b"R. Ierusalimschy, L. H. de Figueiredo & W. Celes\0";
    pub const LUA_SIGNATURE: &[u8; 5] = b"\x1BLua\0";
    pub const LUA_MULTRET: i32 = -1;
    pub const LUA_REGISTRYINDEX: i32 = -10000;
    pub const LUA_ENVIRONINDEX: i32 = -10001;
    pub const LUA_GLOBALSINDEX: i32 = -10002;
    pub const LUA_YIELD: u32 = 1;
    pub const LUA_ERRRUN: u32 = 2;
    pub const LUA_ERRSYNTAX: u32 = 3;
    pub const LUA_ERRMEM: u32 = 4;
    pub const LUA_ERRERR: u32 = 5;
    pub const LUA_TNONE: i32 = -1;
    pub const LUA_TNIL: u32 = 0;
    pub const LUA_TBOOLEAN: u32 = 1;
    pub const LUA_TLIGHTUSERDATA: u32 = 2;
    pub const LUA_TNUMBER: u32 = 3;
    pub const LUA_TSTRING: u32 = 4;
    pub const LUA_TTABLE: u32 = 5;
    pub const LUA_TFUNCTION: u32 = 6;
    pub const LUA_TUSERDATA: u32 = 7;
    pub const LUA_TTHREAD: u32 = 8;
    pub const LUA_MINSTACK: u32 = 20;
    pub const LUA_GCSTOP: u32 = 0;
    pub const LUA_GCRESTART: u32 = 1;
    pub const LUA_GCCOLLECT: u32 = 2;
    pub const LUA_GCCOUNT: u32 = 3;
    pub const LUA_GCCOUNTB: u32 = 4;
    pub const LUA_GCSTEP: u32 = 5;
    pub const LUA_GCSETPAUSE: u32 = 6;
    pub const LUA_GCSETSTEPMUL: u32 = 7;
    pub const LUA_HOOKCALL: u32 = 0;
    pub const LUA_HOOKRET: u32 = 1;
    pub const LUA_HOOKLINE: u32 = 2;
    pub const LUA_HOOKCOUNT: u32 = 3;
    pub const LUA_HOOKTAILRET: u32 = 4;
    pub const LUA_MASKCALL: u32 = 1;
    pub const LUA_MASKRET: u32 = 2;
    pub const LUA_MASKLINE: u32 = 4;
    pub const LUA_MASKCOUNT: u32 = 8;
    pub const LUA_ERRFILE: u32 = 6;
    pub const LUA_NOREF: i32 = -2;
    pub const LUA_REFNIL: i32 = -1;
    pub const _VECTORMATH_SLERP_TOL: f64 = 0.999;
    pub const _VECTORMATH_PI_OVER_2: f64 = 1.570796327;
    pub const HID_NATIVE_MAX_GAMEPAD_COUNT: u32 = 16;
    pub const HID_NATIVE_MAX_KEYBOARD_COUNT: u32 = 1;
    pub const HID_NATIVE_MAX_MOUSE_COUNT: u32 = 1;
    pub const HID_NATIVE_MAX_TOUCH_DEVICE_COUNT: u32 = 1;
    pub const HID_NATIVE_MAX_GAMEPAD_AXIS_COUNT: u32 = 32;
    pub const HID_NATIVE_MAX_GAMEPAD_BUTTON_COUNT: u32 = 32;
    pub const HID_NATIVE_MAX_GAMEPAD_HAT_COUNT: u32 = 4;
    pub const HID_NATIVE_MAX_TOUCH_COUNT: u32 = 11;
    pub const HID_KEY_SPACE: u8 = 32u8;
    pub const HID_KEY_EXCLAIM: u8 = 33u8;
    pub const HID_KEY_QUOTEDBL: u8 = 34u8;
    pub const HID_KEY_HASH: u8 = 35u8;
    pub const HID_KEY_DOLLAR: u8 = 36u8;
    pub const HID_KEY_AMPERSAND: u8 = 38u8;
    pub const HID_KEY_QUOTE: u8 = 39u8;
    pub const HID_KEY_LPAREN: u8 = 40u8;
    pub const HID_KEY_RPAREN: u8 = 41u8;
    pub const HID_KEY_ASTERISK: u8 = 42u8;
    pub const HID_KEY_PLUS: u8 = 43u8;
    pub const HID_KEY_COMMA: u8 = 44u8;
    pub const HID_KEY_MINUS: u8 = 45u8;
    pub const HID_KEY_PERIOD: u8 = 46u8;
    pub const HID_KEY_SLASH: u8 = 47u8;
    pub const HID_KEY_0: u8 = 48u8;
    pub const HID_KEY_1: u8 = 49u8;
    pub const HID_KEY_2: u8 = 50u8;
    pub const HID_KEY_3: u8 = 51u8;
    pub const HID_KEY_4: u8 = 52u8;
    pub const HID_KEY_5: u8 = 53u8;
    pub const HID_KEY_6: u8 = 54u8;
    pub const HID_KEY_7: u8 = 55u8;
    pub const HID_KEY_8: u8 = 56u8;
    pub const HID_KEY_9: u8 = 57u8;
    pub const HID_KEY_COLON: u8 = 58u8;
    pub const HID_KEY_SEMICOLON: u8 = 59u8;
    pub const HID_KEY_LESS: u8 = 60u8;
    pub const HID_KEY_EQUALS: u8 = 61u8;
    pub const HID_KEY_GREATER: u8 = 62u8;
    pub const HID_KEY_QUESTION: u8 = 63u8;
    pub const HID_KEY_AT: u8 = 64u8;
    pub const HID_KEY_A: u8 = 65u8;
    pub const HID_KEY_B: u8 = 66u8;
    pub const HID_KEY_C: u8 = 67u8;
    pub const HID_KEY_D: u8 = 68u8;
    pub const HID_KEY_E: u8 = 69u8;
    pub const HID_KEY_F: u8 = 70u8;
    pub const HID_KEY_G: u8 = 71u8;
    pub const HID_KEY_H: u8 = 72u8;
    pub const HID_KEY_I: u8 = 73u8;
    pub const HID_KEY_J: u8 = 74u8;
    pub const HID_KEY_K: u8 = 75u8;
    pub const HID_KEY_L: u8 = 76u8;
    pub const HID_KEY_M: u8 = 77u8;
    pub const HID_KEY_N: u8 = 78u8;
    pub const HID_KEY_O: u8 = 79u8;
    pub const HID_KEY_P: u8 = 80u8;
    pub const HID_KEY_Q: u8 = 81u8;
    pub const HID_KEY_R: u8 = 82u8;
    pub const HID_KEY_S: u8 = 83u8;
    pub const HID_KEY_T: u8 = 84u8;
    pub const HID_KEY_U: u8 = 85u8;
    pub const HID_KEY_V: u8 = 86u8;
    pub const HID_KEY_W: u8 = 87u8;
    pub const HID_KEY_X: u8 = 88u8;
    pub const HID_KEY_Y: u8 = 89u8;
    pub const HID_KEY_Z: u8 = 90u8;
    pub const HID_KEY_LBRACKET: u8 = 91u8;
    pub const HID_KEY_BACKSLASH: u8 = 92u8;
    pub const HID_KEY_RBRACKET: u8 = 93u8;
    pub const HID_KEY_CARET: u8 = 94u8;
    pub const HID_KEY_UNDERSCORE: u8 = 95u8;
    pub const HID_KEY_BACKQUOTE: u8 = 96u8;
    pub const HID_KEY_LBRACE: u8 = 123u8;
    pub const HID_KEY_PIPE: u8 = 124u8;
    pub const HID_KEY_RBRACE: u8 = 125u8;
    pub const HID_KEY_TILDE: u8 = 126u8;
    pub const HID_SPECIAL_START: u32 = 256;
    pub const HID_KEY_ESC: u32 = 256;
    pub const HID_KEY_F1: u32 = 257;
    pub const HID_KEY_F2: u32 = 258;
    pub const HID_KEY_F3: u32 = 259;
    pub const HID_KEY_F4: u32 = 260;
    pub const HID_KEY_F5: u32 = 261;
    pub const HID_KEY_F6: u32 = 262;
    pub const HID_KEY_F7: u32 = 263;
    pub const HID_KEY_F8: u32 = 264;
    pub const HID_KEY_F9: u32 = 265;
    pub const HID_KEY_F10: u32 = 266;
    pub const HID_KEY_F11: u32 = 267;
    pub const HID_KEY_F12: u32 = 268;
    pub const HID_KEY_UP: u32 = 269;
    pub const HID_KEY_DOWN: u32 = 270;
    pub const HID_KEY_LEFT: u32 = 271;
    pub const HID_KEY_RIGHT: u32 = 272;
    pub const HID_KEY_LSHIFT: u32 = 273;
    pub const HID_KEY_RSHIFT: u32 = 274;
    pub const HID_KEY_LCTRL: u32 = 275;
    pub const HID_KEY_RCTRL: u32 = 276;
    pub const HID_KEY_LALT: u32 = 277;
    pub const HID_KEY_RALT: u32 = 278;
    pub const HID_KEY_TAB: u32 = 279;
    pub const HID_KEY_ENTER: u32 = 280;
    pub const HID_KEY_BACKSPACE: u32 = 281;
    pub const HID_KEY_INSERT: u32 = 282;
    pub const HID_KEY_DEL: u32 = 283;
    pub const HID_KEY_PAGEUP: u32 = 284;
    pub const HID_KEY_PAGEDOWN: u32 = 285;
    pub const HID_KEY_HOME: u32 = 286;
    pub const HID_KEY_END: u32 = 287;
    pub const HID_KEY_KP_0: u32 = 288;
    pub const HID_KEY_KP_1: u32 = 289;
    pub const HID_KEY_KP_2: u32 = 290;
    pub const HID_KEY_KP_3: u32 = 291;
    pub const HID_KEY_KP_4: u32 = 292;
    pub const HID_KEY_KP_5: u32 = 293;
    pub const HID_KEY_KP_6: u32 = 294;
    pub const HID_KEY_KP_7: u32 = 295;
    pub const HID_KEY_KP_8: u32 = 296;
    pub const HID_KEY_KP_9: u32 = 297;
    pub const HID_KEY_KP_DIVIDE: u32 = 298;
    pub const HID_KEY_KP_MULTIPLY: u32 = 299;
    pub const HID_KEY_KP_SUBTRACT: u32 = 300;
    pub const HID_KEY_KP_ADD: u32 = 301;
    pub const HID_KEY_KP_DECIMAL: u32 = 302;
    pub const HID_KEY_KP_EQUAL: u32 = 303;
    pub const HID_KEY_KP_ENTER: u32 = 304;
    pub const HID_KEY_KP_NUM_LOCK: u32 = 305;
    pub const HID_KEY_CAPS_LOCK: u32 = 306;
    pub const HID_KEY_SCROLL_LOCK: u32 = 307;
    pub const HID_KEY_PAUSE: u32 = 308;
    pub const HID_KEY_LSUPER: u32 = 309;
    pub const HID_KEY_RSUPER: u32 = 310;
    pub const HID_KEY_MENU: u32 = 311;
    pub const HID_KEY_BACK: u32 = 312;
    pub const HID_MOUSE_BUTTON_LEFT: u32 = 0;
    pub const HID_MOUSE_BUTTON_MIDDLE: u32 = 1;
    pub const HID_MOUSE_BUTTON_RIGHT: u32 = 2;
    pub const HID_MOUSE_BUTTON_1: u32 = 3;
    pub const HID_MOUSE_BUTTON_2: u32 = 4;
    pub const HID_MOUSE_BUTTON_3: u32 = 5;
    pub const HID_MOUSE_BUTTON_4: u32 = 6;
    pub const HID_MOUSE_BUTTON_5: u32 = 7;
    pub const HID_MOUSE_BUTTON_6: u32 = 8;
    pub const HID_MOUSE_BUTTON_7: u32 = 9;
    pub const HID_MOUSE_BUTTON_8: u32 = 10;
    pub const DLIB_LOG_DOMAIN: &[u8; 8] = b"DEFAULT\0";
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dmAllocator {
        pub m_Alloc: ::std::option::Option<
            unsafe extern "C" fn(
                size: usize,
                user_data: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        pub m_Free: ::std::option::Option<
            unsafe extern "C" fn(
                mem: *mut ::std::os::raw::c_void,
                user_data: *mut ::std::os::raw::c_void,
            ),
        >,
        pub m_UserData: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout_dmAllocator() {
        const UNINIT: ::std::mem::MaybeUninit<dmAllocator> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<dmAllocator>(),
            24usize,
            concat!("Size of: ", stringify!(dmAllocator))
        );
        assert_eq!(
            ::std::mem::align_of::<dmAllocator>(),
            8usize,
            concat!("Alignment of ", stringify!(dmAllocator))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Alloc) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dmAllocator),
                "::",
                stringify!(m_Alloc)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Free) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dmAllocator),
                "::",
                stringify!(m_Free)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dmAllocator),
                "::",
                stringify!(m_UserData)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z10dmMemAllocP11dmAllocatorm"]
        pub fn dmMemAlloc(
            allocator: *mut root::dmAllocator,
            size: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z9dmMemFreeP11dmAllocatorPv"]
        pub fn dmMemFree(allocator: *mut root::dmAllocator, mem: *mut ::std::os::raw::c_void);
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dmFixedMemAllocator {
        pub m_Allocator: root::dmAllocator,
        pub m_Memory: *mut u8,
        pub m_Used: usize,
        pub m_Capacity: usize,
    }
    #[test]
    fn bindgen_test_layout_dmFixedMemAllocator() {
        const UNINIT: ::std::mem::MaybeUninit<dmFixedMemAllocator> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<dmFixedMemAllocator>(),
            48usize,
            concat!("Size of: ", stringify!(dmFixedMemAllocator))
        );
        assert_eq!(
            ::std::mem::align_of::<dmFixedMemAllocator>(),
            8usize,
            concat!("Alignment of ", stringify!(dmFixedMemAllocator))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Allocator) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dmFixedMemAllocator),
                "::",
                stringify!(m_Allocator)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Memory) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dmFixedMemAllocator),
                "::",
                stringify!(m_Memory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Used) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dmFixedMemAllocator),
                "::",
                stringify!(m_Used)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Capacity) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dmFixedMemAllocator),
                "::",
                stringify!(m_Capacity)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23dmFixedMemAllocatorInitP19dmFixedMemAllocatormPv"]
        pub fn dmFixedMemAllocatorInit(
            allocator: *mut root::dmFixedMemAllocator,
            size: usize,
            mem: *mut ::std::os::raw::c_void,
        );
    }
    pub type dmhash_t = u64;
    extern "C" {
        pub fn dmHashBuffer32(buffer: *const ::std::os::raw::c_void, buffer_len: u32) -> u32;
    }
    extern "C" {
        pub fn dmHashBuffer64(buffer: *const ::std::os::raw::c_void, buffer_len: u32) -> u64;
    }
    extern "C" {
        pub fn dmHashString32(string: *const ::std::os::raw::c_char) -> u32;
    }
    extern "C" {
        pub fn dmHashString64(string: *const ::std::os::raw::c_char) -> u64;
    }
    extern "C" {
        pub fn dmHashReverseSafe64(hash: u64) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn dmHashReverse64(hash: u64, length: *mut u32) -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn dmHashReverseSafe32(hash: u32) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn dmHashReverse32(hash: u32, length: *mut u32) -> *const ::std::os::raw::c_void;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HashState32 {
        pub m_Hash: u32,
        pub m_Tail: u32,
        pub m_Count: u32,
        pub m_Size: u32,
        pub m_ReverseHashEntryIndex: u32,
    }
    #[test]
    fn bindgen_test_layout_HashState32() {
        const UNINIT: ::std::mem::MaybeUninit<HashState32> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HashState32>(),
            20usize,
            concat!("Size of: ", stringify!(HashState32))
        );
        assert_eq!(
            ::std::mem::align_of::<HashState32>(),
            4usize,
            concat!("Alignment of ", stringify!(HashState32))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Hash) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState32),
                "::",
                stringify!(m_Hash)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Tail) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState32),
                "::",
                stringify!(m_Tail)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Count) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState32),
                "::",
                stringify!(m_Count)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Size) as usize - ptr as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState32),
                "::",
                stringify!(m_Size)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_ReverseHashEntryIndex) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState32),
                "::",
                stringify!(m_ReverseHashEntryIndex)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct HashState64 {
        pub m_Hash: u64,
        pub m_Tail: u64,
        pub m_Count: u32,
        pub m_Size: u32,
        pub m_ReverseHashEntryIndex: u32,
    }
    #[test]
    fn bindgen_test_layout_HashState64() {
        const UNINIT: ::std::mem::MaybeUninit<HashState64> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<HashState64>(),
            32usize,
            concat!("Size of: ", stringify!(HashState64))
        );
        assert_eq!(
            ::std::mem::align_of::<HashState64>(),
            8usize,
            concat!("Alignment of ", stringify!(HashState64))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Hash) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState64),
                "::",
                stringify!(m_Hash)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Tail) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState64),
                "::",
                stringify!(m_Tail)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Count) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState64),
                "::",
                stringify!(m_Count)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Size) as usize - ptr as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState64),
                "::",
                stringify!(m_Size)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_ReverseHashEntryIndex) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(HashState64),
                "::",
                stringify!(m_ReverseHashEntryIndex)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z12dmHashInit32P11HashState32b"]
        pub fn dmHashInit32(hash_state: *mut root::HashState32, reverse_hash: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z13dmHashClone32P11HashState32PKS_b"]
        pub fn dmHashClone32(
            hash_state: *mut root::HashState32,
            source_hash_state: *const root::HashState32,
            reverse_hash: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z20dmHashUpdateBuffer32P11HashState32PKvj"]
        pub fn dmHashUpdateBuffer32(
            hash_state: *mut root::HashState32,
            buffer: *const ::std::os::raw::c_void,
            buffer_len: u32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z13dmHashFinal32P11HashState32"]
        pub fn dmHashFinal32(hash_state: *mut root::HashState32) -> u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15dmHashRelease32P11HashState32"]
        pub fn dmHashRelease32(hash_state: *mut root::HashState32);
    }
    extern "C" {
        #[link_name = "\u{1}_Z12dmHashInit64P11HashState64b"]
        pub fn dmHashInit64(hash_state: *mut root::HashState64, reverse_hash: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z13dmHashClone64P11HashState64PKS_b"]
        pub fn dmHashClone64(
            hash_state: *mut root::HashState64,
            source_hash_state: *const root::HashState64,
            reverse_hash: bool,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z20dmHashUpdateBuffer64P11HashState64PKvj"]
        pub fn dmHashUpdateBuffer64(
            hash_state: *mut root::HashState64,
            buffer: *const ::std::os::raw::c_void,
            buffer_len: u32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z13dmHashFinal64P11HashState64"]
        pub fn dmHashFinal64(hash_state: *mut root::HashState64) -> u64;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15dmHashRelease64P11HashState64"]
        pub fn dmHashRelease64(hash_state: *mut root::HashState64);
    }
    extern "C" {
        #[link_name = "\u{1}_Z24dmHashReverseSafe64AllocP11dmAllocatorm"]
        pub fn dmHashReverseSafe64Alloc(
            allocator: *mut root::dmAllocator,
            hash: u64,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24dmHashReverseSafe32AllocP11dmAllocatorj"]
        pub fn dmHashReverseSafe32Alloc(
            allocator: *mut root::dmAllocator,
            hash: u32,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceFactory {
        _unused: [u8; 0],
    }
    pub type HResourceFactory = *mut root::ResourceFactory;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourcePreloadHintInfo {
        _unused: [u8; 0],
    }
    pub type HResourcePreloadHintInfo = *mut root::ResourcePreloadHintInfo;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceTypeContext {
        _unused: [u8; 0],
    }
    pub type HResourceTypeContext = *mut root::ResourceTypeContext;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceType {
        _unused: [u8; 0],
    }
    pub type HResourceType = *mut root::ResourceType;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceDescriptor {
        _unused: [u8; 0],
    }
    pub type HResourceDescriptor = *mut root::ResourceDescriptor;
    pub const ResourceResult_RESOURCE_RESULT_OK: root::ResourceResult = 0;
    pub const ResourceResult_RESOURCE_RESULT_INVALID_DATA: root::ResourceResult = -1;
    pub const ResourceResult_RESOURCE_RESULT_DDF_ERROR: root::ResourceResult = -2;
    pub const ResourceResult_RESOURCE_RESULT_RESOURCE_NOT_FOUND: root::ResourceResult = -3;
    pub const ResourceResult_RESOURCE_RESULT_MISSING_FILE_EXTENSION: root::ResourceResult = -4;
    pub const ResourceResult_RESOURCE_RESULT_ALREADY_REGISTERED: root::ResourceResult = -5;
    pub const ResourceResult_RESOURCE_RESULT_INVAL: root::ResourceResult = -6;
    pub const ResourceResult_RESOURCE_RESULT_UNKNOWN_RESOURCE_TYPE: root::ResourceResult = -7;
    pub const ResourceResult_RESOURCE_RESULT_OUT_OF_MEMORY: root::ResourceResult = -8;
    pub const ResourceResult_RESOURCE_RESULT_IO_ERROR: root::ResourceResult = -9;
    pub const ResourceResult_RESOURCE_RESULT_NOT_LOADED: root::ResourceResult = -10;
    pub const ResourceResult_RESOURCE_RESULT_OUT_OF_RESOURCES: root::ResourceResult = -11;
    pub const ResourceResult_RESOURCE_RESULT_STREAMBUFFER_TOO_SMALL: root::ResourceResult = -12;
    pub const ResourceResult_RESOURCE_RESULT_FORMAT_ERROR: root::ResourceResult = -13;
    pub const ResourceResult_RESOURCE_RESULT_CONSTANT_ERROR: root::ResourceResult = -14;
    pub const ResourceResult_RESOURCE_RESULT_NOT_SUPPORTED: root::ResourceResult = -15;
    pub const ResourceResult_RESOURCE_RESULT_RESOURCE_LOOP_ERROR: root::ResourceResult = -16;
    pub const ResourceResult_RESOURCE_RESULT_PENDING: root::ResourceResult = -17;
    pub const ResourceResult_RESOURCE_RESULT_INVALID_FILE_EXTENSION: root::ResourceResult = -18;
    pub const ResourceResult_RESOURCE_RESULT_VERSION_MISMATCH: root::ResourceResult = -19;
    pub const ResourceResult_RESOURCE_RESULT_SIGNATURE_MISMATCH: root::ResourceResult = -20;
    pub const ResourceResult_RESOURCE_RESULT_UNKNOWN_ERROR: root::ResourceResult = -21;
    pub type ResourceResult = ::std::os::raw::c_int;
    pub type FResourceReloadedCallback =
        ::std::option::Option<unsafe extern "C" fn(params: *const root::ResourceReloadedParams)>;
    extern "C" {
        #[doc = " Register a callback function that will be called with the specified user data when a resource has been reloaded.\n The callbacks will not necessarily be called in the order they were registered.\n This has only effect when reloading is supported.\n @name ResourceRegisterReloadedCallback\n @param factory Handle of the factory to which the callback will be registered\n @param callback Callback function to register\n @param user_data User data that will be supplied to the callback when it is called\n @see RESOURCE_FACTORY_FLAGS_RELOAD_SUPPORT (internal flag)"]
        #[link_name = "\u{1}_Z32ResourceRegisterReloadedCallbackP15ResourceFactoryPFvPK22ResourceReloadedParamsEPv"]
        pub fn ResourceRegisterReloadedCallback(
            factory: root::HResourceFactory,
            callback: root::FResourceReloadedCallback,
            user_data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[doc = " Remove a registered callback function, O(n).\n @name ResourceUnregisterReloadedCallback\n @param factory Handle of the factory from which the callback will be removed\n @param callback Callback function to remove\n @param user_data User data that was supplied when the callback was registered\n @see RESOURCE_FACTORY_FLAGS_RELOAD_SUPPORT (internal flag)"]
        #[link_name = "\u{1}_Z34ResourceUnregisterReloadedCallbackP15ResourceFactoryPFvPK22ResourceReloadedParamsEPv"]
        pub fn ResourceUnregisterReloadedCallback(
            factory: root::HResourceFactory,
            callback: root::FResourceReloadedCallback,
            user_data: *mut ::std::os::raw::c_void,
        );
    }
    pub type FResourceDecryption = ::std::option::Option<
        unsafe extern "C" fn(
            buffer: *mut ::std::os::raw::c_void,
            buffer_len: u32,
        ) -> root::ResourceResult,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z34ResourceRegisterDecryptionFunctionPF14ResourceResultPvjE"]
        pub fn ResourceRegisterDecryptionFunction(decrypt_resource: root::FResourceDecryption);
    }
    extern "C" {
        #[link_name = "\u{1}_Z11ResourceGetP15ResourceFactoryPKcPPv"]
        pub fn ResourceGet(
            factory: root::HResourceFactory,
            name: *const ::std::os::raw::c_char,
            resource: *mut *mut ::std::os::raw::c_void,
        ) -> root::ResourceResult;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17ResourceGetByHashP15ResourceFactorymPPv"]
        pub fn ResourceGetByHash(
            factory: root::HResourceFactory,
            name: root::dmhash_t,
            resource: *mut *mut ::std::os::raw::c_void,
        ) -> root::ResourceResult;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15ResourceReleaseP15ResourceFactoryPv"]
        pub fn ResourceRelease(
            factory: root::HResourceFactory,
            resource: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z19ResourcePreloadHintP23ResourcePreloadHintInfoPKc"]
        pub fn ResourcePreloadHint(
            preloader: root::HResourcePreloadHintInfo,
            path: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15ResourceGetPathP15ResourceFactoryPKvPm"]
        pub fn ResourceGetPath(
            factory: root::HResourceFactory,
            resource: *const ::std::os::raw::c_void,
            hash: *mut root::dmhash_t,
        ) -> root::ResourceResult;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15ResourceAddFileP15ResourceFactoryPKcjPKv"]
        pub fn ResourceAddFile(
            factory: root::HResourceFactory,
            path: *const ::std::os::raw::c_char,
            size: u32,
            resource: *const ::std::os::raw::c_void,
        ) -> root::ResourceResult;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18ResourceRemoveFileP15ResourceFactoryPKc"]
        pub fn ResourceRemoveFile(
            factory: root::HResourceFactory,
            path: *const ::std::os::raw::c_char,
        ) -> root::ResourceResult;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29ResourceDescriptorGetNameHashP18ResourceDescriptor"]
        pub fn ResourceDescriptorGetNameHash(rd: root::HResourceDescriptor) -> root::dmhash_t;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29ResourceDescriptorSetResourceP18ResourceDescriptorPv"]
        pub fn ResourceDescriptorSetResource(
            rd: root::HResourceDescriptor,
            resource: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z29ResourceDescriptorGetResourceP18ResourceDescriptor"]
        pub fn ResourceDescriptorGetResource(
            rd: root::HResourceDescriptor,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33ResourceDescriptorSetPrevResourceP18ResourceDescriptorPv"]
        pub fn ResourceDescriptorSetPrevResource(
            rd: root::HResourceDescriptor,
            resource: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z33ResourceDescriptorGetPrevResourceP18ResourceDescriptor"]
        pub fn ResourceDescriptorGetPrevResource(
            rd: root::HResourceDescriptor,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33ResourceDescriptorSetResourceSizeP18ResourceDescriptorj"]
        pub fn ResourceDescriptorSetResourceSize(rd: root::HResourceDescriptor, size: u32);
    }
    extern "C" {
        #[link_name = "\u{1}_Z33ResourceDescriptorGetResourceSizeP18ResourceDescriptor"]
        pub fn ResourceDescriptorGetResourceSize(rd: root::HResourceDescriptor) -> u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25ResourceDescriptorGetTypeP18ResourceDescriptor"]
        pub fn ResourceDescriptorGetType(rd: root::HResourceDescriptor) -> root::HResourceType;
    }
    extern "C" {
        #[link_name = "\u{1}_Z35ResourceTypeContextGetContextByHashP19ResourceTypeContextm"]
        pub fn ResourceTypeContextGetContextByHash(
            arg1: root::HResourceTypeContext,
            extension_hash: root::dmhash_t,
        ) -> *mut ::std::os::raw::c_void;
    }
    pub type FResourceTypeRegister = ::std::option::Option<
        unsafe extern "C" fn(
            ctx: root::HResourceTypeContext,
            type_: root::HResourceType,
        ) -> root::ResourceResult,
    >;
    pub type FResourceTypeDeregister = ::std::option::Option<
        unsafe extern "C" fn(
            ctx: root::HResourceTypeContext,
            type_: root::HResourceType,
        ) -> root::ResourceResult,
    >;
    pub type FResourcePreload = ::std::option::Option<
        unsafe extern "C" fn(params: *const root::ResourcePreloadParams) -> root::ResourceResult,
    >;
    pub type FResourceCreate = ::std::option::Option<
        unsafe extern "C" fn(params: *const root::ResourceCreateParams) -> root::ResourceResult,
    >;
    pub type FResourcePostCreate = ::std::option::Option<
        unsafe extern "C" fn(params: *const root::ResourcePostCreateParams) -> root::ResourceResult,
    >;
    pub type FResourceDestroy = ::std::option::Option<
        unsafe extern "C" fn(params: *const root::ResourceDestroyParams) -> root::ResourceResult,
    >;
    pub type FResourceRecreate = ::std::option::Option<
        unsafe extern "C" fn(params: *const root::ResourceRecreateParams) -> root::ResourceResult,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z22ResourceTypeGetContextP12ResourceType"]
        pub fn ResourceTypeGetContext(type_: root::HResourceType) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22ResourceTypeSetContextP12ResourceTypePv"]
        pub fn ResourceTypeSetContext(
            type_: root::HResourceType,
            context: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z19ResourceTypeGetNameP12ResourceType"]
        pub fn ResourceTypeGetName(type_: root::HResourceType) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23ResourceTypeGetNameHashP12ResourceType"]
        pub fn ResourceTypeGetNameHash(type_: root::HResourceType) -> root::dmhash_t;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24ResourceTypeSetPreloadFnP12ResourceTypePF14ResourceResultPK21ResourcePreloadParamsE"]
        pub fn ResourceTypeSetPreloadFn(type_: root::HResourceType, fn_: root::FResourcePreload);
    }
    extern "C" {
        #[link_name = "\u{1}_Z23ResourceTypeSetCreateFnP12ResourceTypePF14ResourceResultPK20ResourceCreateParamsE"]
        pub fn ResourceTypeSetCreateFn(type_: root::HResourceType, fn_: root::FResourceCreate);
    }
    extern "C" {
        #[link_name = "\u{1}_Z27ResourceTypeSetPostCreateFnP12ResourceTypePF14ResourceResultPK24ResourcePostCreateParamsE"]
        pub fn ResourceTypeSetPostCreateFn(
            type_: root::HResourceType,
            fn_: root::FResourcePostCreate,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24ResourceTypeSetDestroyFnP12ResourceTypePF14ResourceResultPK21ResourceDestroyParamsE"]
        pub fn ResourceTypeSetDestroyFn(type_: root::HResourceType, fn_: root::FResourceDestroy);
    }
    extern "C" {
        #[link_name = "\u{1}_Z25ResourceTypeSetRecreateFnP12ResourceTypePF14ResourceResultPK22ResourceRecreateParamsE"]
        pub fn ResourceTypeSetRecreateFn(type_: root::HResourceType, fn_: root::FResourceRecreate);
    }
    extern "C" {
        #[link_name = "\u{1}_Z20ResourceRegisterTypeP15ResourceFactoryPKcPvPP12ResourceType"]
        pub fn ResourceRegisterType(
            factory: root::HResourceFactory,
            extension: *const ::std::os::raw::c_char,
            context: *mut ::std::os::raw::c_void,
            type_: *mut root::HResourceType,
        ) -> root::ResourceResult;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourcePreloadParams {
        pub m_Factory: root::HResourceFactory,
        pub m_Context: *mut ::std::os::raw::c_void,
        pub m_Filename: *const ::std::os::raw::c_char,
        pub m_Buffer: *const ::std::os::raw::c_void,
        pub m_BufferSize: u32,
        pub m_HintInfo: root::HResourcePreloadHintInfo,
        pub m_PreloadData: *mut *mut ::std::os::raw::c_void,
        pub m_Type: root::HResourceType,
    }
    #[test]
    fn bindgen_test_layout_ResourcePreloadParams() {
        const UNINIT: ::std::mem::MaybeUninit<ResourcePreloadParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ResourcePreloadParams>(),
            64usize,
            concat!("Size of: ", stringify!(ResourcePreloadParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ResourcePreloadParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ResourcePreloadParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Factory) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_Factory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_Context)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Filename) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_Filename)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Buffer) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_Buffer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_BufferSize) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_BufferSize)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_HintInfo) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_HintInfo)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_PreloadData) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_PreloadData)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePreloadParams),
                "::",
                stringify!(m_Type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceCreateParams {
        pub m_Factory: root::HResourceFactory,
        pub m_Context: *mut ::std::os::raw::c_void,
        pub m_Filename: *const ::std::os::raw::c_char,
        pub m_Buffer: *const ::std::os::raw::c_void,
        pub m_BufferSize: u32,
        pub m_PreloadData: *mut ::std::os::raw::c_void,
        pub m_Resource: root::HResourceDescriptor,
        pub m_Type: root::HResourceType,
    }
    #[test]
    fn bindgen_test_layout_ResourceCreateParams() {
        const UNINIT: ::std::mem::MaybeUninit<ResourceCreateParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ResourceCreateParams>(),
            64usize,
            concat!("Size of: ", stringify!(ResourceCreateParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ResourceCreateParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ResourceCreateParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Factory) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_Factory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_Context)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Filename) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_Filename)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Buffer) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_Buffer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_BufferSize) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_BufferSize)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_PreloadData) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_PreloadData)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_Resource)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceCreateParams),
                "::",
                stringify!(m_Type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourcePostCreateParams {
        pub m_Factory: root::HResourceFactory,
        pub m_Context: *mut ::std::os::raw::c_void,
        pub m_Filename: *const ::std::os::raw::c_char,
        pub m_PreloadData: *mut ::std::os::raw::c_void,
        pub m_Resource: root::HResourceDescriptor,
        pub m_Type: root::HResourceType,
    }
    #[test]
    fn bindgen_test_layout_ResourcePostCreateParams() {
        const UNINIT: ::std::mem::MaybeUninit<ResourcePostCreateParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ResourcePostCreateParams>(),
            48usize,
            concat!("Size of: ", stringify!(ResourcePostCreateParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ResourcePostCreateParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ResourcePostCreateParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Factory) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePostCreateParams),
                "::",
                stringify!(m_Factory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePostCreateParams),
                "::",
                stringify!(m_Context)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Filename) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePostCreateParams),
                "::",
                stringify!(m_Filename)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_PreloadData) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePostCreateParams),
                "::",
                stringify!(m_PreloadData)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePostCreateParams),
                "::",
                stringify!(m_Resource)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourcePostCreateParams),
                "::",
                stringify!(m_Type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceRecreateParams {
        pub m_Factory: root::HResourceFactory,
        pub m_Context: *mut ::std::os::raw::c_void,
        pub m_FilenameHash: root::dmhash_t,
        pub m_Filename: *const ::std::os::raw::c_char,
        pub m_Buffer: *const ::std::os::raw::c_void,
        pub m_BufferSize: u32,
        pub m_Message: *const ::std::os::raw::c_void,
        pub m_Resource: root::HResourceDescriptor,
        pub m_Type: root::HResourceType,
    }
    #[test]
    fn bindgen_test_layout_ResourceRecreateParams() {
        const UNINIT: ::std::mem::MaybeUninit<ResourceRecreateParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ResourceRecreateParams>(),
            72usize,
            concat!("Size of: ", stringify!(ResourceRecreateParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ResourceRecreateParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ResourceRecreateParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Factory) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Factory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Context)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_FilenameHash) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_FilenameHash)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Filename) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Filename)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Buffer) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Buffer)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_BufferSize) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_BufferSize)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Message) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Message)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Resource)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceRecreateParams),
                "::",
                stringify!(m_Type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceDestroyParams {
        pub m_Factory: root::HResourceFactory,
        pub m_Context: *mut ::std::os::raw::c_void,
        pub m_Resource: root::HResourceDescriptor,
        pub m_Type: root::HResourceType,
    }
    #[test]
    fn bindgen_test_layout_ResourceDestroyParams() {
        const UNINIT: ::std::mem::MaybeUninit<ResourceDestroyParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ResourceDestroyParams>(),
            32usize,
            concat!("Size of: ", stringify!(ResourceDestroyParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ResourceDestroyParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ResourceDestroyParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Factory) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceDestroyParams),
                "::",
                stringify!(m_Factory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceDestroyParams),
                "::",
                stringify!(m_Context)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceDestroyParams),
                "::",
                stringify!(m_Resource)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceDestroyParams),
                "::",
                stringify!(m_Type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ResourceReloadedParams {
        pub m_UserData: *mut ::std::os::raw::c_void,
        pub m_Filename: *const ::std::os::raw::c_char,
        pub m_FilenameHash: u64,
        pub m_Resource: root::HResourceDescriptor,
        pub m_Type: root::HResourceType,
    }
    #[test]
    fn bindgen_test_layout_ResourceReloadedParams() {
        const UNINIT: ::std::mem::MaybeUninit<ResourceReloadedParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ResourceReloadedParams>(),
            40usize,
            concat!("Size of: ", stringify!(ResourceReloadedParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ResourceReloadedParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ResourceReloadedParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceReloadedParams),
                "::",
                stringify!(m_UserData)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Filename) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceReloadedParams),
                "::",
                stringify!(m_Filename)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_FilenameHash) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceReloadedParams),
                "::",
                stringify!(m_FilenameHash)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceReloadedParams),
                "::",
                stringify!(m_Resource)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ResourceReloadedParams),
                "::",
                stringify!(m_Type)
            )
        );
    }
    pub const ResourceTypeCreatorDescBufferSize: u32 = 128;
    extern "C" {
        #[doc = " Internal\n Resource type creator desc bytesize declaration.\n @name ResourceRegisterTypeCreatorDesc\n @param desc [type: void*] Pointer to allocated area.\n                           Must be valid throughout the application life cycle.\n @param size [type: uint32_t] Size of desc. Must be at least ResourceTypeCreatorDescBufferSize bytes\n @param name [type: const char*] Name of resoruce type (e.g. \"collectionc\")\n @param register_fn [type: FResourceTypeRegister] Type register function. Called at each reboot\n @param deregister_fn [type: FResourceTypeDeregister] Type deregister function. Called at each reboot"]
        #[link_name = "\u{1}_Z31ResourceRegisterTypeCreatorDescPvjPKcPF14ResourceResultP19ResourceTypeContextP12ResourceTypeES8_"]
        pub fn ResourceRegisterTypeCreatorDesc(
            desc: *mut ::std::os::raw::c_void,
            size: u32,
            name: *const ::std::os::raw::c_char,
            register_fn: root::FResourceTypeRegister,
            deregister_fn: root::FResourceTypeDeregister,
        );
    }
    pub mod dmResource {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const Result_RESULT_OK: root::dmResource::Result = 0;
        pub const Result_RESULT_INVALID_DATA: root::dmResource::Result = -1;
        pub const Result_RESULT_DDF_ERROR: root::dmResource::Result = -2;
        pub const Result_RESULT_RESOURCE_NOT_FOUND: root::dmResource::Result = -3;
        pub const Result_RESULT_MISSING_FILE_EXTENSION: root::dmResource::Result = -4;
        pub const Result_RESULT_ALREADY_REGISTERED: root::dmResource::Result = -5;
        pub const Result_RESULT_INVAL: root::dmResource::Result = -6;
        pub const Result_RESULT_UNKNOWN_RESOURCE_TYPE: root::dmResource::Result = -7;
        pub const Result_RESULT_OUT_OF_MEMORY: root::dmResource::Result = -8;
        pub const Result_RESULT_IO_ERROR: root::dmResource::Result = -9;
        pub const Result_RESULT_NOT_LOADED: root::dmResource::Result = -10;
        pub const Result_RESULT_OUT_OF_RESOURCES: root::dmResource::Result = -11;
        pub const Result_RESULT_STREAMBUFFER_TOO_SMALL: root::dmResource::Result = -12;
        pub const Result_RESULT_FORMAT_ERROR: root::dmResource::Result = -13;
        pub const Result_RESULT_CONSTANT_ERROR: root::dmResource::Result = -14;
        pub const Result_RESULT_NOT_SUPPORTED: root::dmResource::Result = -15;
        pub const Result_RESULT_RESOURCE_LOOP_ERROR: root::dmResource::Result = -16;
        pub const Result_RESULT_PENDING: root::dmResource::Result = -17;
        pub const Result_RESULT_INVALID_FILE_EXTENSION: root::dmResource::Result = -18;
        pub const Result_RESULT_VERSION_MISMATCH: root::dmResource::Result = -19;
        pub const Result_RESULT_SIGNATURE_MISMATCH: root::dmResource::Result = -20;
        pub const Result_RESULT_UNKNOWN_ERROR: root::dmResource::Result = -21;
        pub type Result = ::std::os::raw::c_int;
        pub type HFactory = root::HResourceFactory;
        pub type HPreloadHintInfo = root::HResourcePreloadHintInfo;
        pub type HDescriptor = root::HResourceDescriptor;
        pub type ResourceReloadedParams = root::ResourceReloadedParams;
        pub type FReloadedCallback = root::FResourceReloadedCallback;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource3GetEP15ResourceFactoryPKcPPv"]
            pub fn Get(
                factory: root::dmResource::HFactory,
                name: *const ::std::os::raw::c_char,
                resource: *mut *mut ::std::os::raw::c_void,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource9GetByHashEP15ResourceFactorymPPv"]
            pub fn GetByHash(
                factory: root::dmResource::HFactory,
                name: root::dmhash_t,
                resource: *mut *mut ::std::os::raw::c_void,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource7ReleaseEP15ResourceFactoryPv"]
            pub fn Release(
                factory: root::dmResource::HFactory,
                resource: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource11PreloadHintEP23ResourcePreloadHintInfoPKc"]
            pub fn PreloadHint(
                preloader: root::dmResource::HPreloadHintInfo,
                path: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource7GetPathEP15ResourceFactoryPKvPm"]
            pub fn GetPath(
                factory: root::dmResource::HFactory,
                resource: *const ::std::os::raw::c_void,
                hash: *mut root::dmhash_t,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource7AddFileEP15ResourceFactoryPKcjPKv"]
            pub fn AddFile(
                factory: root::dmResource::HFactory,
                path: *const ::std::os::raw::c_char,
                size: u32,
                resource: *const ::std::os::raw::c_void,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource10RemoveFileEP15ResourceFactoryPKc"]
            pub fn RemoveFile(
                factory: root::dmResource::HFactory,
                path: *const ::std::os::raw::c_char,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource11GetNameHashEP18ResourceDescriptor"]
            pub fn GetNameHash(rd: root::dmResource::HDescriptor) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource11SetResourceEP18ResourceDescriptorPv"]
            pub fn SetResource(
                rd: root::dmResource::HDescriptor,
                resource: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource11GetResourceEP18ResourceDescriptor"]
            pub fn GetResource(rd: root::dmResource::HDescriptor) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource15SetPrevResourceEP18ResourceDescriptorPv"]
            pub fn SetPrevResource(
                rd: root::dmResource::HDescriptor,
                resource: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource15GetPrevResourceEP18ResourceDescriptor"]
            pub fn GetPrevResource(
                rd: root::dmResource::HDescriptor,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource15SetResourceSizeEP18ResourceDescriptorj"]
            pub fn SetResourceSize(rd: root::dmResource::HDescriptor, size: u32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource15GetResourceSizeEP18ResourceDescriptor"]
            pub fn GetResourceSize(rd: root::dmResource::HDescriptor) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource7GetTypeEP18ResourceDescriptor"]
            pub fn GetType(rd: root::dmResource::HDescriptor) -> root::HResourceType;
        }
        pub type ResourceCreateParams = root::ResourceCreateParams;
        pub type ResourceDestroyParams = root::ResourceDestroyParams;
        pub type ResourcePreloadParams = root::ResourcePreloadParams;
        pub type ResourcePostCreateParams = root::ResourcePostCreateParams;
        pub type ResourceRecreateParams = root::ResourceRecreateParams;
        pub type HResourceType = root::HResourceType;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource3GetEP15ResourceFactorymPPv"]
            pub fn Get1(
                factory: root::dmResource::HFactory,
                name: root::dmhash_t,
                resource: *mut *mut ::std::os::raw::c_void,
            ) -> root::dmResource::Result;
        }
        pub type FDecryptResource = ::std::option::Option<
            unsafe extern "C" fn(
                buffer: *mut ::std::os::raw::c_void,
                buffer_len: u32,
            ) -> root::dmResource::Result,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource34RegisterResourceDecryptionFunctionEPFNS_6ResultEPvjE"]
            pub fn RegisterResourceDecryptionFunction(
                decrypt_resource: root::dmResource::FDecryptResource,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource32RegisterResourceReloadedCallbackEP15ResourceFactoryPFvPK22ResourceReloadedParamsEPv"]
            pub fn RegisterResourceReloadedCallback(
                factory: root::dmResource::HFactory,
                callback: root::FResourceReloadedCallback,
                user_data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Remove a registered callback function, O(n).\n @name ResourceUnregisterReloadedCallback\n @param factory Handle of the factory from which the callback will be removed\n @param callback Callback function to remove\n @param user_data User data that was supplied when the callback was registered\n @see RESOURCE_FACTORY_FLAGS_RELOAD_SUPPORT"]
            #[link_name = "\u{1}_ZN10dmResource34UnregisterResourceReloadedCallbackEP15ResourceFactoryPFvPK22ResourceReloadedParamsEPv"]
            pub fn UnregisterResourceReloadedCallback(
                factory: root::dmResource::HFactory,
                callback: root::FResourceReloadedCallback,
                user_data: *mut ::std::os::raw::c_void,
            );
        }
        pub const s_ResourceTypeCreatorDescBufferSize: u32 = 128;
        pub type FResourcePreload = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmResource::ResourcePreloadParams,
            ) -> root::dmResource::Result,
        >;
        pub type FResourceCreate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmResource::ResourceCreateParams,
            ) -> root::dmResource::Result,
        >;
        pub type FResourcePostCreate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmResource::ResourcePostCreateParams,
            ) -> root::dmResource::Result,
        >;
        pub type FResourceDestroy = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmResource::ResourceDestroyParams,
            ) -> root::dmResource::Result,
        >;
        pub type FResourceRecreate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmResource::ResourceRecreateParams,
            ) -> root::dmResource::Result,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource12RegisterTypeEP15ResourceFactoryPKcPvPFNS_6ResultEPK21ResourcePreloadParamsEPFS5_PK20ResourceCreateParamsEPFS5_PK24ResourcePostCreateParamsEPFS5_PK21ResourceDestroyParamsEPFS5_PK22ResourceRecreateParamsE"]
            pub fn RegisterType(
                factory: root::dmResource::HFactory,
                extension: *const ::std::os::raw::c_char,
                context: *mut ::std::os::raw::c_void,
                preload_function: root::dmResource::FResourcePreload,
                create_function: root::dmResource::FResourceCreate,
                post_create_function: root::dmResource::FResourcePostCreate,
                destroy_function: root::dmResource::FResourceDestroy,
                recreate_function: root::dmResource::FResourceRecreate,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource9SetupTypeEP19ResourceTypeContextP12ResourceTypePvPFNS_6ResultEPK21ResourcePreloadParamsEPFS5_PK20ResourceCreateParamsEPFS5_PK24ResourcePostCreateParamsEPFS5_PK21ResourceDestroyParamsEPFS5_PK22ResourceRecreateParamsE"]
            pub fn SetupType(
                ctx: root::HResourceTypeContext,
                type_: root::dmResource::HResourceType,
                context: *mut ::std::os::raw::c_void,
                preload_function: root::dmResource::FResourcePreload,
                create_function: root::dmResource::FResourceCreate,
                post_create_function: root::dmResource::FResourcePostCreate,
                destroy_function: root::dmResource::FResourceDestroy,
                recreate_function: root::dmResource::FResourceRecreate,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource20AllocateResourceTypeEP15ResourceFactoryPKc"]
            pub fn AllocateResourceType(
                factory: root::dmResource::HFactory,
                extension: *const ::std::os::raw::c_char,
            ) -> root::dmResource::HResourceType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource16FreeResourceTypeEP15ResourceFactoryP12ResourceType"]
            pub fn FreeResourceType(
                factory: root::dmResource::HFactory,
                type_: root::dmResource::HResourceType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource20ValidateResourceTypeEP12ResourceType"]
            pub fn ValidateResourceType(
                type_: root::dmResource::HResourceType,
            ) -> root::dmResource::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource10GetContextEP12ResourceType"]
            pub fn GetContext(
                type_: root::dmResource::HResourceType,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource10SetContextEP12ResourceTypePv"]
            pub fn SetContext(
                type_: root::dmResource::HResourceType,
                context: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource7GetNameEP12ResourceType"]
            pub fn GetName(type_: root::dmResource::HResourceType)
                -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmResource11GetNameHashEP12ResourceType"]
            pub fn GetNameHash1(type_: root::dmResource::HResourceType) -> root::dmhash_t;
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ConfigFile {
        _unused: [u8; 0],
    }
    pub type HConfigFile = *mut root::ConfigFile;
    extern "C" {
        #[link_name = "\u{1}_Z19ConfigFileGetStringP10ConfigFilePKcS2_"]
        pub fn ConfigFileGetString(
            config: root::HConfigFile,
            key: *const ::std::os::raw::c_char,
            default_value: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16ConfigFileGetIntP10ConfigFilePKci"]
        pub fn ConfigFileGetInt(
            config: root::HConfigFile,
            key: *const ::std::os::raw::c_char,
            default_value: i32,
        ) -> i32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18ConfigFileGetFloatP10ConfigFilePKcf"]
        pub fn ConfigFileGetFloat(
            config: root::HConfigFile,
            key: *const ::std::os::raw::c_char,
            default_value: f32,
        ) -> f32;
    }
    pub type FConfigFileCreate =
        ::std::option::Option<unsafe extern "C" fn(config: root::HConfigFile)>;
    pub type FConfigFileDestroy =
        ::std::option::Option<unsafe extern "C" fn(config: root::HConfigFile)>;
    pub type FConfigFileGetString = ::std::option::Option<
        unsafe extern "C" fn(
            config: root::HConfigFile,
            key: *const ::std::os::raw::c_char,
            default_value: *const ::std::os::raw::c_char,
            out: *mut *const ::std::os::raw::c_char,
        ) -> bool,
    >;
    pub type FConfigFileGetInt = ::std::option::Option<
        unsafe extern "C" fn(
            config: root::HConfigFile,
            key: *const ::std::os::raw::c_char,
            default_value: i32,
            out: *mut i32,
        ) -> bool,
    >;
    pub type FConfigFileGetFloat = ::std::option::Option<
        unsafe extern "C" fn(
            config: root::HConfigFile,
            key: *const ::std::os::raw::c_char,
            default_value: f32,
            out: *mut f32,
        ) -> bool,
    >;
    pub const ConfigFileExtensionDescBufferSize: u32 = 64;
    extern "C" {
        #[link_name = "\u{1}_Z27ConfigFileRegisterExtensionPvjPKcPFvP10ConfigFileES5_PFbS3_S1_S1_PS1_EPFbS3_S1_iPiEPFbS3_S1_fPfE"]
        pub fn ConfigFileRegisterExtension(
            desc: *mut ::std::os::raw::c_void,
            desc_size: u32,
            name: *const ::std::os::raw::c_char,
            create: root::FConfigFileCreate,
            destroy: root::FConfigFileDestroy,
            get_string: root::FConfigFileGetString,
            get_int: root::FConfigFileGetInt,
            get_float: root::FConfigFileGetFloat,
        );
    }
    pub mod dmConfigFile {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type HConfig = root::HConfigFile;
        extern "C" {
            #[link_name = "\u{1}_ZN12dmConfigFile9GetStringEP10ConfigFilePKcS3_"]
            pub fn GetString(
                config: root::dmConfigFile::HConfig,
                key: *const ::std::os::raw::c_char,
                default_value: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmConfigFile6GetIntEP10ConfigFilePKci"]
            pub fn GetInt(
                config: root::dmConfigFile::HConfig,
                key: *const ::std::os::raw::c_char,
                default_value: i32,
            ) -> i32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmConfigFile8GetFloatEP10ConfigFilePKcf"]
            pub fn GetFloat(
                config: root::dmConfigFile::HConfig,
                key: *const ::std::os::raw::c_char,
                default_value: f32,
            ) -> f32;
        }
    }
    pub type va_list = root::__builtin_va_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lua_State {
        _unused: [u8; 0],
    }
    pub type lua_CFunction = ::std::option::Option<
        unsafe extern "C" fn(L: *mut root::lua_State) -> ::std::os::raw::c_int,
    >;
    pub type lua_Reader = ::std::option::Option<
        unsafe extern "C" fn(
            L: *mut root::lua_State,
            ud: *mut ::std::os::raw::c_void,
            sz: *mut usize,
        ) -> *const ::std::os::raw::c_char,
    >;
    pub type lua_Writer = ::std::option::Option<
        unsafe extern "C" fn(
            L: *mut root::lua_State,
            p: *const ::std::os::raw::c_void,
            sz: usize,
            ud: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >;
    pub type lua_Alloc = ::std::option::Option<
        unsafe extern "C" fn(
            ud: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            osize: usize,
            nsize: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type lua_Number = f64;
    pub type lua_Integer = isize;
    extern "C" {
        pub fn lua_newstate(
            f: root::lua_Alloc,
            ud: *mut ::std::os::raw::c_void,
        ) -> *mut root::lua_State;
    }
    extern "C" {
        pub fn lua_close(L: *mut root::lua_State);
    }
    extern "C" {
        pub fn lua_newthread(L: *mut root::lua_State) -> *mut root::lua_State;
    }
    extern "C" {
        pub fn lua_atpanic(
            L: *mut root::lua_State,
            panicf: root::lua_CFunction,
        ) -> root::lua_CFunction;
    }
    extern "C" {
        pub fn lua_gettop(L: *mut root::lua_State) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_settop(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_pushvalue(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_remove(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_insert(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_replace(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_checkstack(
            L: *mut root::lua_State,
            sz: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_xmove(
            from: *mut root::lua_State,
            to: *mut root::lua_State,
            n: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn lua_isnumber(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_isstring(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_iscfunction(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_isuserdata(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_type(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_typename(
            L: *mut root::lua_State,
            tp: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_equal(
            L: *mut root::lua_State,
            idx1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_rawequal(
            L: *mut root::lua_State,
            idx1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_lessthan(
            L: *mut root::lua_State,
            idx1: ::std::os::raw::c_int,
            idx2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_tonumber(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> root::lua_Number;
    }
    extern "C" {
        pub fn lua_tointeger(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> root::lua_Integer;
    }
    extern "C" {
        pub fn lua_toboolean(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_tolstring(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
            len: *mut usize,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_objlen(L: *mut root::lua_State, idx: ::std::os::raw::c_int) -> usize;
    }
    extern "C" {
        pub fn lua_tocfunction(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> root::lua_CFunction;
    }
    extern "C" {
        pub fn lua_touserdata(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn lua_tothread(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> *mut root::lua_State;
    }
    extern "C" {
        pub fn lua_topointer(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn lua_pushnil(L: *mut root::lua_State);
    }
    extern "C" {
        pub fn lua_pushnumber(L: *mut root::lua_State, n: root::lua_Number);
    }
    extern "C" {
        pub fn lua_pushinteger(L: *mut root::lua_State, n: root::lua_Integer);
    }
    extern "C" {
        pub fn lua_pushlstring(L: *mut root::lua_State, s: *const ::std::os::raw::c_char, l: usize);
    }
    extern "C" {
        pub fn lua_pushstring(L: *mut root::lua_State, s: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn lua_pushvfstring(
            L: *mut root::lua_State,
            fmt: *const ::std::os::raw::c_char,
            argp: *mut root::__va_list_tag,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_pushfstring(
            L: *mut root::lua_State,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_pushcclosure(
            L: *mut root::lua_State,
            fn_: root::lua_CFunction,
            n: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn lua_pushboolean(L: *mut root::lua_State, b: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_pushlightuserdata(L: *mut root::lua_State, p: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn lua_pushthread(L: *mut root::lua_State) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_gettable(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_getfield(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
            k: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn lua_rawget(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_rawgeti(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn lua_createtable(
            L: *mut root::lua_State,
            narr: ::std::os::raw::c_int,
            nrec: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn lua_newuserdata(L: *mut root::lua_State, sz: usize) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn lua_getmetatable(
            L: *mut root::lua_State,
            objindex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_getfenv(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_settable(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_setfield(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
            k: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn lua_rawset(L: *mut root::lua_State, idx: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_rawseti(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn lua_setmetatable(
            L: *mut root::lua_State,
            objindex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_setfenv(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_call(
            L: *mut root::lua_State,
            nargs: ::std::os::raw::c_int,
            nresults: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn lua_pcall(
            L: *mut root::lua_State,
            nargs: ::std::os::raw::c_int,
            nresults: ::std::os::raw::c_int,
            errfunc: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_cpcall(
            L: *mut root::lua_State,
            func: root::lua_CFunction,
            ud: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_load(
            L: *mut root::lua_State,
            reader: root::lua_Reader,
            dt: *mut ::std::os::raw::c_void,
            chunkname: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_dump(
            L: *mut root::lua_State,
            writer: root::lua_Writer,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_yield(
            L: *mut root::lua_State,
            nresults: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_resume(
            L: *mut root::lua_State,
            narg: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_status(L: *mut root::lua_State) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_gc(
            L: *mut root::lua_State,
            what: ::std::os::raw::c_int,
            data: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_error(L: *mut root::lua_State) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_next(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_concat(L: *mut root::lua_State, n: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn lua_getallocf(
            L: *mut root::lua_State,
            ud: *mut *mut ::std::os::raw::c_void,
        ) -> root::lua_Alloc;
    }
    extern "C" {
        pub fn lua_setallocf(
            L: *mut root::lua_State,
            f: root::lua_Alloc,
            ud: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        pub fn lua_setlevel(from: *mut root::lua_State, to: *mut root::lua_State);
    }
    pub type lua_Hook = ::std::option::Option<
        unsafe extern "C" fn(L: *mut root::lua_State, ar: *mut root::lua_Debug),
    >;
    extern "C" {
        pub fn lua_getstack(
            L: *mut root::lua_State,
            level: ::std::os::raw::c_int,
            ar: *mut root::lua_Debug,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_getinfo(
            L: *mut root::lua_State,
            what: *const ::std::os::raw::c_char,
            ar: *mut root::lua_Debug,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_getlocal(
            L: *mut root::lua_State,
            ar: *const root::lua_Debug,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_setlocal(
            L: *mut root::lua_State,
            ar: *const root::lua_Debug,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_getupvalue(
            L: *mut root::lua_State,
            funcindex: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_setupvalue(
            L: *mut root::lua_State,
            funcindex: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lua_sethook(
            L: *mut root::lua_State,
            func: root::lua_Hook,
            mask: ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_gethook(L: *mut root::lua_State) -> root::lua_Hook;
    }
    extern "C" {
        pub fn lua_gethookmask(L: *mut root::lua_State) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn lua_gethookcount(L: *mut root::lua_State) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lua_Debug {
        pub event: ::std::os::raw::c_int,
        pub name: *const ::std::os::raw::c_char,
        pub namewhat: *const ::std::os::raw::c_char,
        pub what: *const ::std::os::raw::c_char,
        pub source: *const ::std::os::raw::c_char,
        pub currentline: ::std::os::raw::c_int,
        pub nups: ::std::os::raw::c_int,
        pub linedefined: ::std::os::raw::c_int,
        pub lastlinedefined: ::std::os::raw::c_int,
        pub short_src: [::std::os::raw::c_char; 60usize],
        pub i_ci: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout_lua_Debug() {
        const UNINIT: ::std::mem::MaybeUninit<lua_Debug> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<lua_Debug>(),
            120usize,
            concat!("Size of: ", stringify!(lua_Debug))
        );
        assert_eq!(
            ::std::mem::align_of::<lua_Debug>(),
            8usize,
            concat!("Alignment of ", stringify!(lua_Debug))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(event)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).namewhat) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(namewhat)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).what) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(what)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(source)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).currentline) as usize - ptr as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(currentline)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).nups) as usize - ptr as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(nups)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).linedefined) as usize - ptr as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(linedefined)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).lastlinedefined) as usize - ptr as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(lastlinedefined)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).short_src) as usize - ptr as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(short_src)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).i_ci) as usize - ptr as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(lua_Debug),
                "::",
                stringify!(i_ci)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct luaL_Reg {
        pub name: *const ::std::os::raw::c_char,
        pub func: root::lua_CFunction,
    }
    #[test]
    fn bindgen_test_layout_luaL_Reg() {
        const UNINIT: ::std::mem::MaybeUninit<luaL_Reg> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<luaL_Reg>(),
            16usize,
            concat!("Size of: ", stringify!(luaL_Reg))
        );
        assert_eq!(
            ::std::mem::align_of::<luaL_Reg>(),
            8usize,
            concat!("Alignment of ", stringify!(luaL_Reg))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(luaL_Reg),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(luaL_Reg),
                "::",
                stringify!(func)
            )
        );
    }
    extern "C" {
        pub fn luaL_openlib(
            L: *mut root::lua_State,
            libname: *const ::std::os::raw::c_char,
            l: *const root::luaL_Reg,
            nup: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn luaL_register(
            L: *mut root::lua_State,
            libname: *const ::std::os::raw::c_char,
            l: *const root::luaL_Reg,
        );
    }
    extern "C" {
        pub fn luaL_getmetafield(
            L: *mut root::lua_State,
            obj: ::std::os::raw::c_int,
            e: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_callmeta(
            L: *mut root::lua_State,
            obj: ::std::os::raw::c_int,
            e: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_typerror(
            L: *mut root::lua_State,
            narg: ::std::os::raw::c_int,
            tname: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_argerror(
            L: *mut root::lua_State,
            numarg: ::std::os::raw::c_int,
            extramsg: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_checklstring(
            L: *mut root::lua_State,
            numArg: ::std::os::raw::c_int,
            l: *mut usize,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn luaL_optlstring(
            L: *mut root::lua_State,
            numArg: ::std::os::raw::c_int,
            def: *const ::std::os::raw::c_char,
            l: *mut usize,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn luaL_checknumber(
            L: *mut root::lua_State,
            numArg: ::std::os::raw::c_int,
        ) -> root::lua_Number;
    }
    extern "C" {
        pub fn luaL_optnumber(
            L: *mut root::lua_State,
            nArg: ::std::os::raw::c_int,
            def: root::lua_Number,
        ) -> root::lua_Number;
    }
    extern "C" {
        pub fn luaL_checkinteger(
            L: *mut root::lua_State,
            numArg: ::std::os::raw::c_int,
        ) -> root::lua_Integer;
    }
    extern "C" {
        pub fn luaL_optinteger(
            L: *mut root::lua_State,
            nArg: ::std::os::raw::c_int,
            def: root::lua_Integer,
        ) -> root::lua_Integer;
    }
    extern "C" {
        pub fn luaL_checkstack(
            L: *mut root::lua_State,
            sz: ::std::os::raw::c_int,
            msg: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn luaL_checktype(
            L: *mut root::lua_State,
            narg: ::std::os::raw::c_int,
            t: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn luaL_checkany(L: *mut root::lua_State, narg: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn luaL_newmetatable(
            L: *mut root::lua_State,
            tname: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_checkudata(
            L: *mut root::lua_State,
            ud: ::std::os::raw::c_int,
            tname: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn luaL_where(L: *mut root::lua_State, lvl: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn luaL_error(
            L: *mut root::lua_State,
            fmt: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_checkoption(
            L: *mut root::lua_State,
            narg: ::std::os::raw::c_int,
            def: *const ::std::os::raw::c_char,
            lst: *const *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_ref(L: *mut root::lua_State, t: ::std::os::raw::c_int)
            -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_unref(
            L: *mut root::lua_State,
            t: ::std::os::raw::c_int,
            ref_: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn luaL_loadfile(
            L: *mut root::lua_State,
            filename: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_loadbuffer(
            L: *mut root::lua_State,
            buff: *const ::std::os::raw::c_char,
            sz: usize,
            name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_loadstring(
            L: *mut root::lua_State,
            s: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn luaL_newstate() -> *mut root::lua_State;
    }
    extern "C" {
        pub fn luaL_gsub(
            L: *mut root::lua_State,
            s: *const ::std::os::raw::c_char,
            p: *const ::std::os::raw::c_char,
            r: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn luaL_findtable(
            L: *mut root::lua_State,
            idx: ::std::os::raw::c_int,
            fname: *const ::std::os::raw::c_char,
            szhint: ::std::os::raw::c_int,
        ) -> *const ::std::os::raw::c_char;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct luaL_Buffer {
        pub p: *mut ::std::os::raw::c_char,
        pub lvl: ::std::os::raw::c_int,
        pub L: *mut root::lua_State,
        pub buffer: [::std::os::raw::c_char; 8192usize],
    }
    #[test]
    fn bindgen_test_layout_luaL_Buffer() {
        const UNINIT: ::std::mem::MaybeUninit<luaL_Buffer> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<luaL_Buffer>(),
            8216usize,
            concat!("Size of: ", stringify!(luaL_Buffer))
        );
        assert_eq!(
            ::std::mem::align_of::<luaL_Buffer>(),
            8usize,
            concat!("Alignment of ", stringify!(luaL_Buffer))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(luaL_Buffer),
                "::",
                stringify!(p)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).lvl) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(luaL_Buffer),
                "::",
                stringify!(lvl)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).L) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(luaL_Buffer),
                "::",
                stringify!(L)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(luaL_Buffer),
                "::",
                stringify!(buffer)
            )
        );
    }
    extern "C" {
        pub fn luaL_buffinit(L: *mut root::lua_State, B: *mut root::luaL_Buffer);
    }
    extern "C" {
        pub fn luaL_prepbuffer(B: *mut root::luaL_Buffer) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn luaL_addlstring(
            B: *mut root::luaL_Buffer,
            s: *const ::std::os::raw::c_char,
            l: usize,
        );
    }
    extern "C" {
        pub fn luaL_addstring(B: *mut root::luaL_Buffer, s: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn luaL_addvalue(B: *mut root::luaL_Buffer);
    }
    extern "C" {
        pub fn luaL_pushresult(B: *mut root::luaL_Buffer);
    }
    pub const ExtensionResult_EXTENSION_RESULT_OK: root::ExtensionResult = 0;
    pub const ExtensionResult_EXTENSION_RESULT_INIT_ERROR: root::ExtensionResult = -1;
    pub type ExtensionResult = ::std::os::raw::c_int;
    pub const ExtensionEventID_EXTENSION_EVENT_ID_ACTIVATEAPP: root::ExtensionEventID = 0;
    pub const ExtensionEventID_EXTENSION_EVENT_ID_DEACTIVATEAPP: root::ExtensionEventID = 1;
    pub const ExtensionEventID_EXTENSION_EVENT_ID_ICONIFYAPP: root::ExtensionEventID = 2;
    pub const ExtensionEventID_EXTENSION_EVENT_ID_DEICONIFYAPP: root::ExtensionEventID = 3;
    pub const ExtensionEventID_EXTENSION_EVENT_ID_ENGINE_INITIALIZED: root::ExtensionEventID = 4;
    pub const ExtensionEventID_EXTENSION_EVENT_ID_ENGINE_DELETE: root::ExtensionEventID = 5;
    pub type ExtensionEventID = ::std::os::raw::c_uint;
    pub const ExtensionCallbackType_EXTENSION_CALLBACK_PRE_RENDER: root::ExtensionCallbackType = 0;
    pub const ExtensionCallbackType_EXTENSION_CALLBACK_POST_RENDER: root::ExtensionCallbackType = 1;
    pub type ExtensionCallbackType = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ExtensionAppParams {
        pub m_ConfigFile: root::HConfigFile,
    }
    #[test]
    fn bindgen_test_layout_ExtensionAppParams() {
        const UNINIT: ::std::mem::MaybeUninit<ExtensionAppParams> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ExtensionAppParams>(),
            8usize,
            concat!("Size of: ", stringify!(ExtensionAppParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ExtensionAppParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ExtensionAppParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_ConfigFile) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExtensionAppParams),
                "::",
                stringify!(m_ConfigFile)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ExtensionParams {
        pub m_ConfigFile: root::HConfigFile,
        pub m_ResourceFactory: root::HResourceFactory,
        pub m_L: *mut root::lua_State,
    }
    #[test]
    fn bindgen_test_layout_ExtensionParams() {
        const UNINIT: ::std::mem::MaybeUninit<ExtensionParams> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ExtensionParams>(),
            24usize,
            concat!("Size of: ", stringify!(ExtensionParams))
        );
        assert_eq!(
            ::std::mem::align_of::<ExtensionParams>(),
            8usize,
            concat!("Alignment of ", stringify!(ExtensionParams))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_ConfigFile) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExtensionParams),
                "::",
                stringify!(m_ConfigFile)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_ResourceFactory) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ExtensionParams),
                "::",
                stringify!(m_ResourceFactory)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_L) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ExtensionParams),
                "::",
                stringify!(m_L)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ExtensionEvent {
        pub m_Event: root::ExtensionEventID,
    }
    #[test]
    fn bindgen_test_layout_ExtensionEvent() {
        const UNINIT: ::std::mem::MaybeUninit<ExtensionEvent> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<ExtensionEvent>(),
            4usize,
            concat!("Size of: ", stringify!(ExtensionEvent))
        );
        assert_eq!(
            ::std::mem::align_of::<ExtensionEvent>(),
            4usize,
            concat!("Alignment of ", stringify!(ExtensionEvent))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).m_Event) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ExtensionEvent),
                "::",
                stringify!(m_Event)
            )
        );
    }
    pub type FExtensionAppInitialize = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::ExtensionAppParams) -> root::ExtensionResult,
    >;
    pub type FExtensionAppFinalize = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::ExtensionAppParams) -> root::ExtensionResult,
    >;
    pub type FExtensionInitialize = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::ExtensionParams) -> root::ExtensionResult,
    >;
    pub type FExtensionFinalize = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::ExtensionParams) -> root::ExtensionResult,
    >;
    pub type FExtensionUpdate = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::ExtensionParams) -> root::ExtensionResult,
    >;
    pub type FExtensionOnEvent = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::ExtensionParams, arg2: *const root::ExtensionEvent),
    >;
    pub type FExtensionCallback = ::std::option::Option<
        unsafe extern "C" fn(params: *mut root::ExtensionParams) -> root::ExtensionResult,
    >;
    pub const ExtensionDescBufferSize: usize = 128;
    extern "C" {
        pub fn ExtensionRegister(
            desc: *mut ::std::os::raw::c_void,
            desc_size: u32,
            name: *const ::std::os::raw::c_char,
            app_initialize: root::FExtensionAppInitialize,
            app_finalize: root::FExtensionAppFinalize,
            initialize: root::FExtensionInitialize,
            finalize: root::FExtensionFinalize,
            update: root::FExtensionUpdate,
            on_event: root::FExtensionOnEvent,
        );
    }
    extern "C" {
        #[doc = " currently internal\n Used for registing a pre or post render callback"]
        pub fn ExtensionRegisterCallback(
            callback_type: root::ExtensionCallbackType,
            func: root::FExtensionCallback,
        ) -> bool;
    }
    extern "C" {
        pub fn ExtensionRegisteriOSUIApplicationDelegate(delegate: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn ExtensionUnregisteriOSUIApplicationDelegate(delegate: *mut ::std::os::raw::c_void);
    }
    pub mod dmExtension {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const Result_RESULT_OK: root::dmExtension::Result = 0;
        pub const Result_RESULT_INIT_ERROR: root::dmExtension::Result = -1;
        pub type Result = ::std::os::raw::c_int;
        pub const EventID_EVENT_ID_ACTIVATEAPP: root::dmExtension::EventID = 0;
        pub const EventID_EVENT_ID_DEACTIVATEAPP: root::dmExtension::EventID = 1;
        pub const EventID_EVENT_ID_ICONIFYAPP: root::dmExtension::EventID = 2;
        pub const EventID_EVENT_ID_DEICONIFYAPP: root::dmExtension::EventID = 3;
        pub const EventID_EVENT_ID_ENGINE_INITIALIZED: root::dmExtension::EventID = 4;
        pub const EventID_EVENT_ID_ENGINE_DELETE: root::dmExtension::EventID = 5;
        pub type EventID = ::std::os::raw::c_uint;
        pub const CallbackType_CALLBACK_PRE_RENDER: root::dmExtension::CallbackType = 0;
        pub const CallbackType_CALLBACK_POST_RENDER: root::dmExtension::CallbackType = 1;
        pub type CallbackType = ::std::os::raw::c_uint;
        pub type AppParams = root::ExtensionAppParams;
        pub type Params = root::ExtensionParams;
        pub type Event = root::ExtensionEvent;
        pub type FCallback = root::FExtensionCallback;
        extern "C" {
            #[link_name = "\u{1}_ZN11dmExtension16RegisterCallbackENS_12CallbackTypeEPF15ExtensionResultP15ExtensionParamsE"]
            pub fn RegisterCallback(
                callback_type: root::dmExtension::CallbackType,
                func: root::dmExtension::FCallback,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmExtension32RegisteriOSUIApplicationDelegateEPv"]
            pub fn RegisteriOSUIApplicationDelegate(delegate: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmExtension34UnregisteriOSUIApplicationDelegateEPv"]
            pub fn UnregisteriOSUIApplicationDelegate(delegate: *mut ::std::os::raw::c_void);
        }
    }
    extern "C" {
        #[link_name = "\u{1}_Z28EngineExtensionGetConfigFileP18ExtensionAppParams"]
        pub fn EngineExtensionGetConfigFile(
            app_params: *mut root::ExtensionAppParams,
        ) -> root::HConfigFile;
    }
    pub mod dmSocket {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const SOCKET_TIMEOUT: ::std::os::raw::c_int = 500000;
        pub type Socket = ::std::os::raw::c_int;
        pub const INVALID_SOCKET_HANDLE: root::dmSocket::Socket = -1;
        pub const Flags_FLAGS_UP: root::dmSocket::Flags = 1;
        pub const Flags_FLAGS_RUNNING: root::dmSocket::Flags = 2;
        pub const Flags_FLAGS_INET: root::dmSocket::Flags = 4;
        pub const Flags_FLAGS_LINK: root::dmSocket::Flags = 8;
        pub type Flags = ::std::os::raw::c_uint;
        pub const Domain_DOMAIN_MISSING: root::dmSocket::Domain = 0;
        pub const Domain_DOMAIN_IPV4: root::dmSocket::Domain = 1;
        pub const Domain_DOMAIN_IPV6: root::dmSocket::Domain = 2;
        pub const Domain_DOMAIN_UNKNOWN: root::dmSocket::Domain = 3;
        pub type Domain = ::std::os::raw::c_uint;
        pub const Type_TYPE_STREAM: root::dmSocket::Type = 0;
        pub const Type_TYPE_DGRAM: root::dmSocket::Type = 1;
        pub type Type = ::std::os::raw::c_uint;
        pub const Protocol_PROTOCOL_TCP: root::dmSocket::Protocol = 0;
        pub const Protocol_PROTOCOL_UDP: root::dmSocket::Protocol = 1;
        pub type Protocol = ::std::os::raw::c_uint;
        pub const ShutdownType_SHUTDOWNTYPE_READ: root::dmSocket::ShutdownType = 0;
        pub const ShutdownType_SHUTDOWNTYPE_WRITE: root::dmSocket::ShutdownType = 1;
        pub const ShutdownType_SHUTDOWNTYPE_READWRITE: root::dmSocket::ShutdownType = 2;
        pub type ShutdownType = ::std::os::raw::c_uint;
        pub const Result_RESULT_OK: root::dmSocket::Result = 0;
        pub const Result_RESULT_ACCES: root::dmSocket::Result = -1;
        pub const Result_RESULT_AFNOSUPPORT: root::dmSocket::Result = -2;
        pub const Result_RESULT_WOULDBLOCK: root::dmSocket::Result = -3;
        pub const Result_RESULT_BADF: root::dmSocket::Result = -4;
        pub const Result_RESULT_CONNRESET: root::dmSocket::Result = -5;
        pub const Result_RESULT_DESTADDRREQ: root::dmSocket::Result = -6;
        pub const Result_RESULT_FAULT: root::dmSocket::Result = -7;
        pub const Result_RESULT_HOSTUNREACH: root::dmSocket::Result = -8;
        pub const Result_RESULT_INTR: root::dmSocket::Result = -9;
        pub const Result_RESULT_INVAL: root::dmSocket::Result = -10;
        pub const Result_RESULT_ISCONN: root::dmSocket::Result = -11;
        pub const Result_RESULT_MFILE: root::dmSocket::Result = -12;
        pub const Result_RESULT_MSGSIZE: root::dmSocket::Result = -13;
        pub const Result_RESULT_NETDOWN: root::dmSocket::Result = -14;
        pub const Result_RESULT_NETUNREACH: root::dmSocket::Result = -15;
        pub const Result_RESULT_NOBUFS: root::dmSocket::Result = -17;
        pub const Result_RESULT_NOTCONN: root::dmSocket::Result = -20;
        pub const Result_RESULT_NOTSOCK: root::dmSocket::Result = -22;
        pub const Result_RESULT_OPNOTSUPP: root::dmSocket::Result = -23;
        pub const Result_RESULT_PIPE: root::dmSocket::Result = -24;
        pub const Result_RESULT_PROTONOSUPPORT: root::dmSocket::Result = -25;
        pub const Result_RESULT_PROTOTYPE: root::dmSocket::Result = -26;
        pub const Result_RESULT_TIMEDOUT: root::dmSocket::Result = -27;
        pub const Result_RESULT_ADDRNOTAVAIL: root::dmSocket::Result = -28;
        pub const Result_RESULT_CONNREFUSED: root::dmSocket::Result = -29;
        pub const Result_RESULT_ADDRINUSE: root::dmSocket::Result = -30;
        pub const Result_RESULT_CONNABORTED: root::dmSocket::Result = -31;
        pub const Result_RESULT_INPROGRESS: root::dmSocket::Result = -32;
        pub const Result_RESULT_HOST_NOT_FOUND: root::dmSocket::Result = -100;
        pub const Result_RESULT_TRY_AGAIN: root::dmSocket::Result = -101;
        pub const Result_RESULT_NO_RECOVERY: root::dmSocket::Result = -102;
        pub const Result_RESULT_NO_DATA: root::dmSocket::Result = -103;
        pub const Result_RESULT_UNKNOWN: root::dmSocket::Result = -1000;
        pub type Result = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Address {
            pub m_family: root::dmSocket::Domain,
            pub m_address: [u32; 4usize],
        }
        #[test]
        fn bindgen_test_layout_Address() {
            const UNINIT: ::std::mem::MaybeUninit<Address> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Address>(),
                20usize,
                concat!("Size of: ", stringify!(Address))
            );
            assert_eq!(
                ::std::mem::align_of::<Address>(),
                4usize,
                concat!("Alignment of ", stringify!(Address))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_family) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Address),
                    "::",
                    stringify!(m_family)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_address) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Address),
                    "::",
                    stringify!(m_address)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket7AddressC1Ev"]
            pub fn Address_Address(this: *mut root::dmSocket::Address);
        }
        impl Address {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Address_Address(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket3NewENS_6DomainENS_4TypeENS_8ProtocolEPi"]
            pub fn New(
                domain: root::dmSocket::Domain,
                type_: root::dmSocket::Type,
                protocol: root::dmSocket::Protocol,
                socket: *mut root::dmSocket::Socket,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket6DeleteEi"]
            pub fn Delete(socket: root::dmSocket::Socket) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket7ConnectEiNS_7AddressEi"]
            pub fn Connect(
                socket: root::dmSocket::Socket,
                address: root::dmSocket::Address,
                port: ::std::os::raw::c_int,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket8ShutdownEiNS_12ShutdownTypeE"]
            pub fn Shutdown(
                socket: root::dmSocket::Socket,
                how: root::dmSocket::ShutdownType,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket5GetFDEi"]
            pub fn GetFD(socket: root::dmSocket::Socket) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket15SetReuseAddressEib"]
            pub fn SetReuseAddress(
                socket: root::dmSocket::Socket,
                reuse: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket12SetBroadcastEib"]
            pub fn SetBroadcast(
                socket: root::dmSocket::Socket,
                broadcast: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket11SetBlockingEib"]
            pub fn SetBlocking(
                socket: root::dmSocket::Socket,
                blocking: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket10SetNoDelayEib"]
            pub fn SetNoDelay(
                socket: root::dmSocket::Socket,
                no_delay: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket11SetQuickAckEib"]
            pub fn SetQuickAck(
                socket: root::dmSocket::Socket,
                use_quick_ack: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket14SetSendTimeoutEim"]
            pub fn SetSendTimeout(
                socket: root::dmSocket::Socket,
                timeout: u64,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket17SetReceiveTimeoutEim"]
            pub fn SetReceiveTimeout(
                socket: root::dmSocket::Socket,
                timeout: u64,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket4SendEiPKviPi"]
            pub fn Send(
                socket: root::dmSocket::Socket,
                buffer: *const ::std::os::raw::c_void,
                length: ::std::os::raw::c_int,
                sent_bytes: *mut ::std::os::raw::c_int,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket7ReceiveEiPviPi"]
            pub fn Receive(
                socket: root::dmSocket::Socket,
                buffer: *mut ::std::os::raw::c_void,
                length: ::std::os::raw::c_int,
                received_bytes: *mut ::std::os::raw::c_int,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket13GetHostByNameEPKcPNS_7AddressEbb"]
            pub fn GetHostByName(
                name: *const ::std::os::raw::c_char,
                address: *mut root::dmSocket::Address,
                ipv4: bool,
                ipv6: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket14GetHostByNameTEPKcPNS_7AddressEmPibb"]
            pub fn GetHostByNameT(
                name: *const ::std::os::raw::c_char,
                address: *mut root::dmSocket::Address,
                timeout: u64,
                cancelflag: *mut ::std::os::raw::c_int,
                ipv4: bool,
                ipv6: bool,
            ) -> root::dmSocket::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket14ResultToStringENS_6ResultE"]
            pub fn ResultToString(result: root::dmSocket::Result) -> *const ::std::os::raw::c_char;
        }
        pub const SelectorKind_SELECTOR_KIND_READ: root::dmSocket::SelectorKind = 0;
        pub const SelectorKind_SELECTOR_KIND_WRITE: root::dmSocket::SelectorKind = 1;
        pub const SelectorKind_SELECTOR_KIND_EXCEPT: root::dmSocket::SelectorKind = 2;
        pub type SelectorKind = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug)]
        pub struct Selector {
            pub m_Poller: root::dmFileDescriptor::Poller,
        }
        #[test]
        fn bindgen_test_layout_Selector() {
            const UNINIT: ::std::mem::MaybeUninit<Selector> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Selector>(),
                32usize,
                concat!("Size of: ", stringify!(Selector))
            );
            assert_eq!(
                ::std::mem::align_of::<Selector>(),
                8usize,
                concat!("Alignment of ", stringify!(Selector))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Poller) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Selector),
                    "::",
                    stringify!(m_Poller)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket8SelectorC1Ev"]
            pub fn Selector_Selector(this: *mut root::dmSocket::Selector);
        }
        impl Selector {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Selector_Selector(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket13SelectorClearEPNS_8SelectorENS_12SelectorKindEi"]
            pub fn SelectorClear(
                selector: *mut root::dmSocket::Selector,
                selector_kind: root::dmSocket::SelectorKind,
                socket: root::dmSocket::Socket,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket11SelectorSetEPNS_8SelectorENS_12SelectorKindEi"]
            pub fn SelectorSet(
                selector: *mut root::dmSocket::Selector,
                selector_kind: root::dmSocket::SelectorKind,
                socket: root::dmSocket::Socket,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket13SelectorIsSetEPNS_8SelectorENS_12SelectorKindEi"]
            pub fn SelectorIsSet(
                selector: *mut root::dmSocket::Selector,
                selector_kind: root::dmSocket::SelectorKind,
                socket: root::dmSocket::Socket,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket12SelectorZeroEPNS_8SelectorE"]
            pub fn SelectorZero(selector: *mut root::dmSocket::Selector);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmSocket6SelectEPNS_8SelectorEi"]
            pub fn Select(
                selector: *mut root::dmSocket::Selector,
                timeout: i32,
            ) -> root::dmSocket::Result;
        }
    }
    pub mod dmArrayUtil {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[doc = " Set capacity of an array, given front, back and end array pointers\n @param capacity new capacity\n @param type_size size of array element\n @param first pointer to a pointer containing the first array element\n @param last pointer to a pointer containing the last array element\n @param end pointer to a pointer containing the end array element"]
            #[link_name = "\u{1}_ZN11dmArrayUtil11SetCapacityEjjPmS0_S0_"]
            pub fn SetCapacity(
                capacity: u32,
                type_size: u32,
                first: *mut usize,
                last: *mut usize,
                end: *mut usize,
            );
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dmArray<T> {
        pub m_Front: *mut T,
        pub m_End: *mut T,
        pub m_Back: *mut T,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    impl<T> dmArray<T> {
        #[inline]
        pub fn m_UserAllocated(&self) -> u16 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_m_UserAllocated(&mut self, val: u16) {
            unsafe {
                let val: u16 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(m_UserAllocated: u16) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let m_UserAllocated: u16 = unsafe { ::std::mem::transmute(m_UserAllocated) };
                m_UserAllocated as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pollfd {
        pub fd: ::std::os::raw::c_int,
        pub events: ::std::os::raw::c_short,
        pub revents: ::std::os::raw::c_short,
    }
    #[test]
    fn bindgen_test_layout_pollfd() {
        const UNINIT: ::std::mem::MaybeUninit<pollfd> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<pollfd>(),
            8usize,
            concat!("Size of: ", stringify!(pollfd))
        );
        assert_eq!(
            ::std::mem::align_of::<pollfd>(),
            4usize,
            concat!("Alignment of ", stringify!(pollfd))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(fd)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(events)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(revents)
            )
        );
    }
    pub mod dmFileDescriptor {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type PollFD = root::pollfd;
        pub const PollEvent_EVENT_READ: root::dmFileDescriptor::PollEvent = 0;
        pub const PollEvent_EVENT_WRITE: root::dmFileDescriptor::PollEvent = 1;
        pub const PollEvent_EVENT_ERROR: root::dmFileDescriptor::PollEvent = 2;
        pub type PollEvent = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug)]
        pub struct Poller {
            pub m_Pollfds: root::dmArray<root::dmFileDescriptor::PollFD>,
        }
        #[test]
        fn bindgen_test_layout_Poller() {
            const UNINIT: ::std::mem::MaybeUninit<Poller> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Poller>(),
                32usize,
                concat!("Size of: ", stringify!(Poller))
            );
            assert_eq!(
                ::std::mem::align_of::<Poller>(),
                8usize,
                concat!("Alignment of ", stringify!(Poller))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Pollfds) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Poller),
                    "::",
                    stringify!(m_Pollfds)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN16dmFileDescriptor16PollerClearEventEPNS_6PollerENS_9PollEventEi"]
            pub fn PollerClearEvent(
                poller: *mut root::dmFileDescriptor::Poller,
                event: root::dmFileDescriptor::PollEvent,
                fd: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN16dmFileDescriptor14PollerSetEventEPNS_6PollerENS_9PollEventEi"]
            pub fn PollerSetEvent(
                poller: *mut root::dmFileDescriptor::Poller,
                event: root::dmFileDescriptor::PollEvent,
                fd: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN16dmFileDescriptor14PollerHasEventEPNS_6PollerENS_9PollEventEi"]
            pub fn PollerHasEvent(
                poller: *mut root::dmFileDescriptor::Poller,
                event: root::dmFileDescriptor::PollEvent,
                fd: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN16dmFileDescriptor11PollerResetEPNS_6PollerE"]
            pub fn PollerReset(poller: *mut root::dmFileDescriptor::Poller);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN16dmFileDescriptor4WaitEPNS_6PollerEi"]
            pub fn Wait(
                poller: *mut root::dmFileDescriptor::Poller,
                timeout: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
    }
    pub mod dmWebServer {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Server {
            _unused: [u8; 0],
        }
        pub type HServer = *mut root::dmWebServer::Server;
        pub const Result_RESULT_OK: root::dmWebServer::Result = 0;
        pub const Result_RESULT_SOCKET_ERROR: root::dmWebServer::Result = -1;
        pub const Result_RESULT_INVALID_REQUEST: root::dmWebServer::Result = -2;
        pub const Result_RESULT_ERROR_INVAL: root::dmWebServer::Result = -3;
        pub const Result_RESULT_HANDLER_ALREADY_REGISTRED: root::dmWebServer::Result = -4;
        pub const Result_RESULT_HANDLER_NOT_REGISTRED: root::dmWebServer::Result = -5;
        pub const Result_RESULT_INTERNAL_ERROR: root::dmWebServer::Result = -100;
        pub const Result_RESULT_UNKNOWN: root::dmWebServer::Result = -1000;
        pub type Result = ::std::os::raw::c_int;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Request {
            pub m_Method: *const ::std::os::raw::c_char,
            pub m_Resource: *const ::std::os::raw::c_char,
            pub m_ContentLength: u32,
            pub m_Internal: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_Request() {
            const UNINIT: ::std::mem::MaybeUninit<Request> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Request>(),
                32usize,
                concat!("Size of: ", stringify!(Request))
            );
            assert_eq!(
                ::std::mem::align_of::<Request>(),
                8usize,
                concat!("Alignment of ", stringify!(Request))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Method) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Request),
                    "::",
                    stringify!(m_Method)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Request),
                    "::",
                    stringify!(m_Resource)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ContentLength) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Request),
                    "::",
                    stringify!(m_ContentLength)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Internal) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Request),
                    "::",
                    stringify!(m_Internal)
                )
            );
        }
        pub type Handler = ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                request: *mut root::dmWebServer::Request,
            ),
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandlerParams {
            pub m_Userdata: *mut ::std::os::raw::c_void,
            pub m_Handler: root::dmWebServer::Handler,
        }
        #[test]
        fn bindgen_test_layout_HandlerParams() {
            const UNINIT: ::std::mem::MaybeUninit<HandlerParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<HandlerParams>(),
                16usize,
                concat!("Size of: ", stringify!(HandlerParams))
            );
            assert_eq!(
                ::std::mem::align_of::<HandlerParams>(),
                8usize,
                concat!("Alignment of ", stringify!(HandlerParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Userdata) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandlerParams),
                    "::",
                    stringify!(m_Userdata)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Handler) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandlerParams),
                    "::",
                    stringify!(m_Handler)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer10AddHandlerEPNS_6ServerEPKcPKNS_13HandlerParamsE"]
            pub fn AddHandler(
                server: root::dmWebServer::HServer,
                prefix: *const ::std::os::raw::c_char,
                handler_params: *const root::dmWebServer::HandlerParams,
            ) -> root::dmWebServer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer13RemoveHandlerEPNS_6ServerEPKc"]
            pub fn RemoveHandler(
                server: root::dmWebServer::HServer,
                prefix: *const ::std::os::raw::c_char,
            ) -> root::dmWebServer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer13SetStatusCodeEPNS_7RequestEi"]
            pub fn SetStatusCode(
                request: *mut root::dmWebServer::Request,
                status_code: ::std::os::raw::c_int,
            ) -> root::dmWebServer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer9GetHeaderEPNS_7RequestEPKc"]
            pub fn GetHeader(
                request: *mut root::dmWebServer::Request,
                name: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer4SendEPNS_7RequestEPKvj"]
            pub fn Send(
                request: *mut root::dmWebServer::Request,
                data: *const ::std::os::raw::c_void,
                data_length: u32,
            ) -> root::dmWebServer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer7ReceiveEPNS_7RequestEPvjPj"]
            pub fn Receive(
                request: *mut root::dmWebServer::Request,
                buffer: *mut ::std::os::raw::c_void,
                buffer_size: u32,
                received_bytes: *mut u32,
            ) -> root::dmWebServer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN11dmWebServer13SendAttributeEPNS_7RequestEPKcS3_"]
            pub fn SendAttribute(
                request: *mut root::dmWebServer::Request,
                key: *const ::std::os::raw::c_char,
                value: *const ::std::os::raw::c_char,
            ) -> root::dmWebServer::Result;
        }
    }
    pub mod dmMessage {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const Result_RESULT_OK: root::dmMessage::Result = 0;
        pub const Result_RESULT_SOCKET_EXISTS: root::dmMessage::Result = -1;
        pub const Result_RESULT_SOCKET_NOT_FOUND: root::dmMessage::Result = -2;
        pub const Result_RESULT_SOCKET_OUT_OF_RESOURCES: root::dmMessage::Result = -3;
        pub const Result_RESULT_INVALID_SOCKET_NAME: root::dmMessage::Result = -4;
        pub const Result_RESULT_MALFORMED_URL: root::dmMessage::Result = -5;
        pub const Result_RESULT_NAME_OK_SOCKET_NOT_FOUND: root::dmMessage::Result = -6;
        pub type Result = ::std::os::raw::c_int;
        pub type HSocket = root::dmhash_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct URL {
            pub m_Socket: root::dmMessage::HSocket,
            pub _reserved: root::dmhash_t,
            pub m_Path: root::dmhash_t,
            pub m_Fragment: root::dmhash_t,
        }
        #[test]
        fn bindgen_test_layout_URL() {
            const UNINIT: ::std::mem::MaybeUninit<URL> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<URL>(),
                32usize,
                concat!("Size of: ", stringify!(URL))
            );
            assert_eq!(
                ::std::mem::align_of::<URL>(),
                8usize,
                concat!("Alignment of ", stringify!(URL))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Socket) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(URL),
                    "::",
                    stringify!(m_Socket)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(URL),
                    "::",
                    stringify!(_reserved)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Path) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(URL),
                    "::",
                    stringify!(m_Path)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Fragment) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(URL),
                    "::",
                    stringify!(m_Fragment)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringURL {
            pub m_Socket: *const ::std::os::raw::c_char,
            pub m_SocketSize: u32,
            pub m_Path: *const ::std::os::raw::c_char,
            pub m_PathSize: u32,
            pub m_Fragment: *const ::std::os::raw::c_char,
            pub m_FragmentSize: u32,
        }
        #[test]
        fn bindgen_test_layout_StringURL() {
            const UNINIT: ::std::mem::MaybeUninit<StringURL> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<StringURL>(),
                48usize,
                concat!("Size of: ", stringify!(StringURL))
            );
            assert_eq!(
                ::std::mem::align_of::<StringURL>(),
                8usize,
                concat!("Alignment of ", stringify!(StringURL))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Socket) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringURL),
                    "::",
                    stringify!(m_Socket)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_SocketSize) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringURL),
                    "::",
                    stringify!(m_SocketSize)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Path) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringURL),
                    "::",
                    stringify!(m_Path)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PathSize) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringURL),
                    "::",
                    stringify!(m_PathSize)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Fragment) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringURL),
                    "::",
                    stringify!(m_Fragment)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_FragmentSize) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringURL),
                    "::",
                    stringify!(m_FragmentSize)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage8ResetURLEPNS_3URLE"]
            pub fn ResetURL(url: *mut root::dmMessage::URL);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage9GetSocketEPKNS_3URLE"]
            pub fn GetSocket(url: *const root::dmMessage::URL) -> root::dmMessage::HSocket;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage9SetSocketEPNS_3URLEm"]
            pub fn SetSocket(url: *mut root::dmMessage::URL, socket: root::dmMessage::HSocket);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage13IsSocketValidEm"]
            pub fn IsSocketValid(socket: root::dmMessage::HSocket) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage13GetSocketNameEm"]
            pub fn GetSocketName(socket: root::dmMessage::HSocket)
                -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage7GetPathEPKNS_3URLE"]
            pub fn GetPath(url: *const root::dmMessage::URL) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage7SetPathEPNS_3URLEm"]
            pub fn SetPath(url: *mut root::dmMessage::URL, path: root::dmhash_t);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage11GetFragmentEPKNS_3URLE"]
            pub fn GetFragment(url: *const root::dmMessage::URL) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage11SetFragmentEPNS_3URLEm"]
            pub fn SetFragment(url: *mut root::dmMessage::URL, fragment: root::dmhash_t);
        }
        pub type MessageDestroyCallback =
            ::std::option::Option<unsafe extern "C" fn(message: *mut root::dmMessage::Message)>;
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug)]
        pub struct Message {
            pub m_Sender: root::dmMessage::URL,
            #[doc = "! Sender uri"]
            pub m_Receiver: root::dmMessage::URL,
            #[doc = "! Receiver uri"]
            pub m_Id: root::dmhash_t,
            #[doc = "! Unique id of message"]
            pub m_UserData1: usize,
            #[doc = "! User data pointer"]
            pub m_UserData2: usize,
            #[doc = "! User data pointer"]
            pub m_Descriptor: usize,
            #[doc = "! User specified descriptor of the message data"]
            pub m_DataSize: u32,
            #[doc = "! Size of message data in bytes"]
            pub m_Next: *mut root::dmMessage::Message,
            #[doc = "! Ptr to next message (or 0 if last)"]
            pub m_DestroyCallback: root::dmMessage::MessageDestroyCallback,
            pub __bindgen_padding_0: [u8; 8usize],
            #[doc = "! If set, will be called after each dispatch"]
            pub m_Data: root::__IncompleteArrayField<u8>,
        }
        #[test]
        fn bindgen_test_layout_Message() {
            const UNINIT: ::std::mem::MaybeUninit<Message> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Message>(),
                128usize,
                concat!("Size of: ", stringify!(Message))
            );
            assert_eq!(
                ::std::mem::align_of::<Message>(),
                16usize,
                concat!("Alignment of ", stringify!(Message))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Sender) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_Sender)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Receiver) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_Receiver)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Id) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_Id)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData1) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_UserData1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData2) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_UserData2)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Descriptor) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_Descriptor)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DataSize) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_DataSize)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Next) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_Next)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DestroyCallback) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_DestroyCallback)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Data) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Message),
                    "::",
                    stringify!(m_Data)
                )
            );
        }
        extern "C" {
            #[doc = " Post an message to a socket\n @note Message data is copied by value\n @name Post\n @param sender [type: dmMessage::URL*] The sender URL if the receiver wants to respond. 0x0 is accepted\n @param receiver [type: dmMessage::URL*] The receiver URL, must not be 0x0\n @param message_id [type: dmhash_t] Message id\n @param user_data1 [type: uintptr_t] User data that can be used when both the sender and receiver are known\n @param user_data2 [type: uintptr_t] User data that can be used when both the sender and receiver are known.\n @param descriptor [type: uintptr_t] User specified descriptor of the message data\n @param message_data [type: void*] Message data reference\n @param message_data_size [type: uint32_t] Message data size in bytes\n @param destroy_callback [type: dmMessage::MessageDestroyCallback] if set, will be called after each message dispatch\n @return RESULT_OK if the message was posted"]
            #[link_name = "\u{1}_ZN9dmMessage4PostEPKNS_3URLES2_mmmmPKvjPFvPNS_7MessageEE"]
            pub fn Post(
                sender: *const root::dmMessage::URL,
                receiver: *const root::dmMessage::URL,
                message_id: root::dmhash_t,
                user_data1: usize,
                user_data2: usize,
                descriptor: usize,
                message_data: *const ::std::os::raw::c_void,
                message_data_size: u32,
                destroy_callback: root::dmMessage::MessageDestroyCallback,
            ) -> root::dmMessage::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN9dmMessage8ParseURLEPKcPNS_9StringURLE"]
            pub fn ParseURL(
                uri: *const ::std::os::raw::c_char,
                out_url: *mut root::dmMessage::StringURL,
            ) -> root::dmMessage::Result;
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod Vectormath {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod Aos {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Vector3 {
                pub mX: f32,
                pub mY: f32,
                pub mZ: f32,
            }
            #[test]
            fn bindgen_test_layout_Vector3() {
                const UNINIT: ::std::mem::MaybeUninit<Vector3> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Vector3>(),
                    16usize,
                    concat!("Size of: ", stringify!(Vector3))
                );
                assert_eq!(
                    ::std::mem::align_of::<Vector3>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Vector3))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mX) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector3),
                        "::",
                        stringify!(mX)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mY) as usize - ptr as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector3),
                        "::",
                        stringify!(mY)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mZ) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector3),
                        "::",
                        stringify!(mZ)
                    )
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Vector4 {
                pub mX: f32,
                pub mY: f32,
                pub mZ: f32,
                pub mW: f32,
            }
            #[test]
            fn bindgen_test_layout_Vector4() {
                const UNINIT: ::std::mem::MaybeUninit<Vector4> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Vector4>(),
                    16usize,
                    concat!("Size of: ", stringify!(Vector4))
                );
                assert_eq!(
                    ::std::mem::align_of::<Vector4>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Vector4))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mX) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector4),
                        "::",
                        stringify!(mX)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mY) as usize - ptr as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector4),
                        "::",
                        stringify!(mY)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mZ) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector4),
                        "::",
                        stringify!(mZ)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mW) as usize - ptr as usize },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector4),
                        "::",
                        stringify!(mW)
                    )
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Point3 {
                pub mX: f32,
                pub mY: f32,
                pub mZ: f32,
            }
            #[test]
            fn bindgen_test_layout_Point3() {
                const UNINIT: ::std::mem::MaybeUninit<Point3> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Point3>(),
                    16usize,
                    concat!("Size of: ", stringify!(Point3))
                );
                assert_eq!(
                    ::std::mem::align_of::<Point3>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Point3))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mX) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Point3),
                        "::",
                        stringify!(mX)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mY) as usize - ptr as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Point3),
                        "::",
                        stringify!(mY)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mZ) as usize - ptr as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Point3),
                        "::",
                        stringify!(mZ)
                    )
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Quat {
                pub mX: f32,
                pub mY: f32,
                pub mZ: f32,
                pub mW: f32,
            }
            #[test]
            fn bindgen_test_layout_Quat() {
                const UNINIT: ::std::mem::MaybeUninit<Quat> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Quat>(),
                    16usize,
                    concat!("Size of: ", stringify!(Quat))
                );
                assert_eq!(
                    ::std::mem::align_of::<Quat>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Quat))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mX) as usize - ptr as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(Quat), "::", stringify!(mX))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mY) as usize - ptr as usize },
                    4usize,
                    concat!("Offset of field: ", stringify!(Quat), "::", stringify!(mY))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mZ) as usize - ptr as usize },
                    8usize,
                    concat!("Offset of field: ", stringify!(Quat), "::", stringify!(mZ))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mW) as usize - ptr as usize },
                    12usize,
                    concat!("Offset of field: ", stringify!(Quat), "::", stringify!(mW))
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Matrix3 {
                pub mCol0: root::Vectormath::Aos::Vector3,
                pub mCol1: root::Vectormath::Aos::Vector3,
                pub mCol2: root::Vectormath::Aos::Vector3,
            }
            #[test]
            fn bindgen_test_layout_Matrix3() {
                const UNINIT: ::std::mem::MaybeUninit<Matrix3> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Matrix3>(),
                    48usize,
                    concat!("Size of: ", stringify!(Matrix3))
                );
                assert_eq!(
                    ::std::mem::align_of::<Matrix3>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Matrix3))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol0) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix3),
                        "::",
                        stringify!(mCol0)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol1) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix3),
                        "::",
                        stringify!(mCol1)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol2) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix3),
                        "::",
                        stringify!(mCol2)
                    )
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Matrix4 {
                pub mCol0: root::Vectormath::Aos::Vector4,
                pub mCol1: root::Vectormath::Aos::Vector4,
                pub mCol2: root::Vectormath::Aos::Vector4,
                pub mCol3: root::Vectormath::Aos::Vector4,
            }
            #[test]
            fn bindgen_test_layout_Matrix4() {
                const UNINIT: ::std::mem::MaybeUninit<Matrix4> = ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Matrix4>(),
                    64usize,
                    concat!("Size of: ", stringify!(Matrix4))
                );
                assert_eq!(
                    ::std::mem::align_of::<Matrix4>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Matrix4))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol0) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix4),
                        "::",
                        stringify!(mCol0)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol1) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix4),
                        "::",
                        stringify!(mCol1)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol2) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix4),
                        "::",
                        stringify!(mCol2)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol3) as usize - ptr as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Matrix4),
                        "::",
                        stringify!(mCol3)
                    )
                );
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug, Copy, Clone)]
            pub struct Transform3 {
                pub mCol0: root::Vectormath::Aos::Vector3,
                pub mCol1: root::Vectormath::Aos::Vector3,
                pub mCol2: root::Vectormath::Aos::Vector3,
                pub mCol3: root::Vectormath::Aos::Vector3,
            }
            #[test]
            fn bindgen_test_layout_Transform3() {
                const UNINIT: ::std::mem::MaybeUninit<Transform3> =
                    ::std::mem::MaybeUninit::uninit();
                let ptr = UNINIT.as_ptr();
                assert_eq!(
                    ::std::mem::size_of::<Transform3>(),
                    64usize,
                    concat!("Size of: ", stringify!(Transform3))
                );
                assert_eq!(
                    ::std::mem::align_of::<Transform3>(),
                    16usize,
                    concat!("Alignment of ", stringify!(Transform3))
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol0) as usize - ptr as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Transform3),
                        "::",
                        stringify!(mCol0)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol1) as usize - ptr as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Transform3),
                        "::",
                        stringify!(mCol1)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol2) as usize - ptr as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Transform3),
                        "::",
                        stringify!(mCol2)
                    )
                );
                assert_eq!(
                    unsafe { ::std::ptr::addr_of!((*ptr).mCol3) as usize - ptr as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Transform3),
                        "::",
                        stringify!(mCol3)
                    )
                );
            }
        }
    }
    pub mod dmVMath {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type Point3 = root::Vectormath::Aos::Point3;
        pub type Vector3 = root::Vectormath::Aos::Vector3;
        pub type Vector4 = root::Vectormath::Aos::Vector4;
        pub type Quat = root::Vectormath::Aos::Quat;
        pub type Matrix3 = root::Vectormath::Aos::Matrix3;
        pub type Matrix4 = root::Vectormath::Aos::Matrix4;
    }
    pub mod dmHID {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Context {
            _unused: [u8; 0],
        }
        pub type HContext = *mut root::dmHID::Context;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Gamepad {
            _unused: [u8; 0],
        }
        pub type HGamepad = *mut root::dmHID::Gamepad;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Mouse {
            _unused: [u8; 0],
        }
        pub type HMouse = *mut root::dmHID::Mouse;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Keyboard {
            _unused: [u8; 0],
        }
        pub type HKeyboard = *mut root::dmHID::Keyboard;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TouchDevice {
            _unused: [u8; 0],
        }
        pub type HTouchDevice = *mut root::dmHID::TouchDevice;
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHIDL22INVALID_GAMEPAD_HANDLEE"]
            pub static INVALID_GAMEPAD_HANDLE: root::dmHID::HGamepad;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHIDL23INVALID_KEYBOARD_HANDLEE"]
            pub static INVALID_KEYBOARD_HANDLE: root::dmHID::HKeyboard;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHIDL20INVALID_MOUSE_HANDLEE"]
            pub static INVALID_MOUSE_HANDLE: root::dmHID::HMouse;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHIDL27INVALID_TOUCH_DEVICE_HANDLEE"]
            pub static INVALID_TOUCH_DEVICE_HANDLE: root::dmHID::HTouchDevice;
        }
        pub const MAX_GAMEPAD_COUNT: u32 = 16;
        pub const MAX_GAMEPAD_AXIS_COUNT: u32 = 32;
        pub const MAX_GAMEPAD_BUTTON_COUNT: u32 = 32;
        pub const MAX_GAMEPAD_HAT_COUNT: u32 = 4;
        pub const MAX_TOUCH_COUNT: u32 = 11;
        pub const MAX_KEYBOARD_COUNT: u32 = 1;
        pub const MAX_MOUSE_COUNT: u32 = 1;
        pub const MAX_TOUCH_DEVICE_COUNT: u32 = 1;
        pub const MAX_CHAR_COUNT: u32 = 256;
        pub const Phase_PHASE_BEGAN: root::dmHID::Phase = 0;
        pub const Phase_PHASE_MOVED: root::dmHID::Phase = 1;
        pub const Phase_PHASE_STATIONARY: root::dmHID::Phase = 2;
        pub const Phase_PHASE_ENDED: root::dmHID::Phase = 3;
        pub const Phase_PHASE_CANCELLED: root::dmHID::Phase = 4;
        pub type Phase = ::std::os::raw::c_uint;
        pub const Key_KEY_SPACE: root::dmHID::Key = 32;
        pub const Key_KEY_EXCLAIM: root::dmHID::Key = 33;
        pub const Key_KEY_QUOTEDBL: root::dmHID::Key = 34;
        pub const Key_KEY_HASH: root::dmHID::Key = 35;
        pub const Key_KEY_DOLLAR: root::dmHID::Key = 36;
        pub const Key_KEY_AMPERSAND: root::dmHID::Key = 38;
        pub const Key_KEY_QUOTE: root::dmHID::Key = 39;
        pub const Key_KEY_LPAREN: root::dmHID::Key = 40;
        pub const Key_KEY_RPAREN: root::dmHID::Key = 41;
        pub const Key_KEY_ASTERISK: root::dmHID::Key = 42;
        pub const Key_KEY_PLUS: root::dmHID::Key = 43;
        pub const Key_KEY_COMMA: root::dmHID::Key = 44;
        pub const Key_KEY_MINUS: root::dmHID::Key = 45;
        pub const Key_KEY_PERIOD: root::dmHID::Key = 46;
        pub const Key_KEY_SLASH: root::dmHID::Key = 47;
        pub const Key_KEY_0: root::dmHID::Key = 48;
        pub const Key_KEY_1: root::dmHID::Key = 49;
        pub const Key_KEY_2: root::dmHID::Key = 50;
        pub const Key_KEY_3: root::dmHID::Key = 51;
        pub const Key_KEY_4: root::dmHID::Key = 52;
        pub const Key_KEY_5: root::dmHID::Key = 53;
        pub const Key_KEY_6: root::dmHID::Key = 54;
        pub const Key_KEY_7: root::dmHID::Key = 55;
        pub const Key_KEY_8: root::dmHID::Key = 56;
        pub const Key_KEY_9: root::dmHID::Key = 57;
        pub const Key_KEY_COLON: root::dmHID::Key = 58;
        pub const Key_KEY_SEMICOLON: root::dmHID::Key = 59;
        pub const Key_KEY_LESS: root::dmHID::Key = 60;
        pub const Key_KEY_EQUALS: root::dmHID::Key = 61;
        pub const Key_KEY_GREATER: root::dmHID::Key = 62;
        pub const Key_KEY_QUESTION: root::dmHID::Key = 63;
        pub const Key_KEY_AT: root::dmHID::Key = 64;
        pub const Key_KEY_A: root::dmHID::Key = 65;
        pub const Key_KEY_B: root::dmHID::Key = 66;
        pub const Key_KEY_C: root::dmHID::Key = 67;
        pub const Key_KEY_D: root::dmHID::Key = 68;
        pub const Key_KEY_E: root::dmHID::Key = 69;
        pub const Key_KEY_F: root::dmHID::Key = 70;
        pub const Key_KEY_G: root::dmHID::Key = 71;
        pub const Key_KEY_H: root::dmHID::Key = 72;
        pub const Key_KEY_I: root::dmHID::Key = 73;
        pub const Key_KEY_J: root::dmHID::Key = 74;
        pub const Key_KEY_K: root::dmHID::Key = 75;
        pub const Key_KEY_L: root::dmHID::Key = 76;
        pub const Key_KEY_M: root::dmHID::Key = 77;
        pub const Key_KEY_N: root::dmHID::Key = 78;
        pub const Key_KEY_O: root::dmHID::Key = 79;
        pub const Key_KEY_P: root::dmHID::Key = 80;
        pub const Key_KEY_Q: root::dmHID::Key = 81;
        pub const Key_KEY_R: root::dmHID::Key = 82;
        pub const Key_KEY_S: root::dmHID::Key = 83;
        pub const Key_KEY_T: root::dmHID::Key = 84;
        pub const Key_KEY_U: root::dmHID::Key = 85;
        pub const Key_KEY_V: root::dmHID::Key = 86;
        pub const Key_KEY_W: root::dmHID::Key = 87;
        pub const Key_KEY_X: root::dmHID::Key = 88;
        pub const Key_KEY_Y: root::dmHID::Key = 89;
        pub const Key_KEY_Z: root::dmHID::Key = 90;
        pub const Key_KEY_LBRACKET: root::dmHID::Key = 91;
        pub const Key_KEY_BACKSLASH: root::dmHID::Key = 92;
        pub const Key_KEY_RBRACKET: root::dmHID::Key = 93;
        pub const Key_KEY_CARET: root::dmHID::Key = 94;
        pub const Key_KEY_UNDERSCORE: root::dmHID::Key = 95;
        pub const Key_KEY_BACKQUOTE: root::dmHID::Key = 96;
        pub const Key_KEY_LBRACE: root::dmHID::Key = 123;
        pub const Key_KEY_PIPE: root::dmHID::Key = 124;
        pub const Key_KEY_RBRACE: root::dmHID::Key = 125;
        pub const Key_KEY_TILDE: root::dmHID::Key = 126;
        pub const Key_KEY_ESC: root::dmHID::Key = 256;
        pub const Key_KEY_F1: root::dmHID::Key = 257;
        pub const Key_KEY_F2: root::dmHID::Key = 258;
        pub const Key_KEY_F3: root::dmHID::Key = 259;
        pub const Key_KEY_F4: root::dmHID::Key = 260;
        pub const Key_KEY_F5: root::dmHID::Key = 261;
        pub const Key_KEY_F6: root::dmHID::Key = 262;
        pub const Key_KEY_F7: root::dmHID::Key = 263;
        pub const Key_KEY_F8: root::dmHID::Key = 264;
        pub const Key_KEY_F9: root::dmHID::Key = 265;
        pub const Key_KEY_F10: root::dmHID::Key = 266;
        pub const Key_KEY_F11: root::dmHID::Key = 267;
        pub const Key_KEY_F12: root::dmHID::Key = 268;
        pub const Key_KEY_UP: root::dmHID::Key = 269;
        pub const Key_KEY_DOWN: root::dmHID::Key = 270;
        pub const Key_KEY_LEFT: root::dmHID::Key = 271;
        pub const Key_KEY_RIGHT: root::dmHID::Key = 272;
        pub const Key_KEY_LSHIFT: root::dmHID::Key = 273;
        pub const Key_KEY_RSHIFT: root::dmHID::Key = 274;
        pub const Key_KEY_LCTRL: root::dmHID::Key = 275;
        pub const Key_KEY_RCTRL: root::dmHID::Key = 276;
        pub const Key_KEY_LALT: root::dmHID::Key = 277;
        pub const Key_KEY_RALT: root::dmHID::Key = 278;
        pub const Key_KEY_TAB: root::dmHID::Key = 279;
        pub const Key_KEY_ENTER: root::dmHID::Key = 280;
        pub const Key_KEY_BACKSPACE: root::dmHID::Key = 281;
        pub const Key_KEY_INSERT: root::dmHID::Key = 282;
        pub const Key_KEY_DEL: root::dmHID::Key = 283;
        pub const Key_KEY_PAGEUP: root::dmHID::Key = 284;
        pub const Key_KEY_PAGEDOWN: root::dmHID::Key = 285;
        pub const Key_KEY_HOME: root::dmHID::Key = 286;
        pub const Key_KEY_END: root::dmHID::Key = 287;
        pub const Key_KEY_KP_0: root::dmHID::Key = 288;
        pub const Key_KEY_KP_1: root::dmHID::Key = 289;
        pub const Key_KEY_KP_2: root::dmHID::Key = 290;
        pub const Key_KEY_KP_3: root::dmHID::Key = 291;
        pub const Key_KEY_KP_4: root::dmHID::Key = 292;
        pub const Key_KEY_KP_5: root::dmHID::Key = 293;
        pub const Key_KEY_KP_6: root::dmHID::Key = 294;
        pub const Key_KEY_KP_7: root::dmHID::Key = 295;
        pub const Key_KEY_KP_8: root::dmHID::Key = 296;
        pub const Key_KEY_KP_9: root::dmHID::Key = 297;
        pub const Key_KEY_KP_DIVIDE: root::dmHID::Key = 298;
        pub const Key_KEY_KP_MULTIPLY: root::dmHID::Key = 299;
        pub const Key_KEY_KP_SUBTRACT: root::dmHID::Key = 300;
        pub const Key_KEY_KP_ADD: root::dmHID::Key = 301;
        pub const Key_KEY_KP_DECIMAL: root::dmHID::Key = 302;
        pub const Key_KEY_KP_EQUAL: root::dmHID::Key = 303;
        pub const Key_KEY_KP_ENTER: root::dmHID::Key = 304;
        pub const Key_KEY_KP_NUM_LOCK: root::dmHID::Key = 305;
        pub const Key_KEY_CAPS_LOCK: root::dmHID::Key = 306;
        pub const Key_KEY_SCROLL_LOCK: root::dmHID::Key = 307;
        pub const Key_KEY_PAUSE: root::dmHID::Key = 308;
        pub const Key_KEY_LSUPER: root::dmHID::Key = 309;
        pub const Key_KEY_RSUPER: root::dmHID::Key = 310;
        pub const Key_KEY_MENU: root::dmHID::Key = 311;
        pub const Key_KEY_BACK: root::dmHID::Key = 312;
        pub const Key_MAX_KEY_COUNT: root::dmHID::Key = 313;
        pub type Key = ::std::os::raw::c_uint;
        pub const MouseButton_MOUSE_BUTTON_LEFT: root::dmHID::MouseButton = 0;
        pub const MouseButton_MOUSE_BUTTON_MIDDLE: root::dmHID::MouseButton = 1;
        pub const MouseButton_MOUSE_BUTTON_RIGHT: root::dmHID::MouseButton = 2;
        pub const MouseButton_MOUSE_BUTTON_1: root::dmHID::MouseButton = 3;
        pub const MouseButton_MOUSE_BUTTON_2: root::dmHID::MouseButton = 4;
        pub const MouseButton_MOUSE_BUTTON_3: root::dmHID::MouseButton = 5;
        pub const MouseButton_MOUSE_BUTTON_4: root::dmHID::MouseButton = 6;
        pub const MouseButton_MOUSE_BUTTON_5: root::dmHID::MouseButton = 7;
        pub const MouseButton_MOUSE_BUTTON_6: root::dmHID::MouseButton = 8;
        pub const MouseButton_MOUSE_BUTTON_7: root::dmHID::MouseButton = 9;
        pub const MouseButton_MOUSE_BUTTON_8: root::dmHID::MouseButton = 10;
        pub const MouseButton_MAX_MOUSE_BUTTON_COUNT: root::dmHID::MouseButton = 11;
        pub type MouseButton = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct KeyboardPacket {
            pub m_Keys: [u32; 10usize],
        }
        #[test]
        fn bindgen_test_layout_KeyboardPacket() {
            const UNINIT: ::std::mem::MaybeUninit<KeyboardPacket> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<KeyboardPacket>(),
                40usize,
                concat!("Size of: ", stringify!(KeyboardPacket))
            );
            assert_eq!(
                ::std::mem::align_of::<KeyboardPacket>(),
                4usize,
                concat!("Alignment of ", stringify!(KeyboardPacket))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Keys) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(KeyboardPacket),
                    "::",
                    stringify!(m_Keys)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MousePacket {
            pub m_PositionX: i32,
            pub m_PositionY: i32,
            pub m_Wheel: i32,
            pub m_Buttons: [u32; 1usize],
        }
        #[test]
        fn bindgen_test_layout_MousePacket() {
            const UNINIT: ::std::mem::MaybeUninit<MousePacket> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<MousePacket>(),
                16usize,
                concat!("Size of: ", stringify!(MousePacket))
            );
            assert_eq!(
                ::std::mem::align_of::<MousePacket>(),
                4usize,
                concat!("Alignment of ", stringify!(MousePacket))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PositionX) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MousePacket),
                    "::",
                    stringify!(m_PositionX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PositionY) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MousePacket),
                    "::",
                    stringify!(m_PositionY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Wheel) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MousePacket),
                    "::",
                    stringify!(m_Wheel)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Buttons) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MousePacket),
                    "::",
                    stringify!(m_Buttons)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GamepadPacket {
            pub m_Axis: [f32; 32usize],
            pub m_Buttons: [u32; 2usize],
            pub m_Hat: [u8; 4usize],
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[test]
        fn bindgen_test_layout_GamepadPacket() {
            const UNINIT: ::std::mem::MaybeUninit<GamepadPacket> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GamepadPacket>(),
                144usize,
                concat!("Size of: ", stringify!(GamepadPacket))
            );
            assert_eq!(
                ::std::mem::align_of::<GamepadPacket>(),
                4usize,
                concat!("Alignment of ", stringify!(GamepadPacket))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Axis) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GamepadPacket),
                    "::",
                    stringify!(m_Axis)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Buttons) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GamepadPacket),
                    "::",
                    stringify!(m_Buttons)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Hat) as usize - ptr as usize },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GamepadPacket),
                    "::",
                    stringify!(m_Hat)
                )
            );
        }
        impl GamepadPacket {
            #[inline]
            pub fn m_GamepadDisconnected(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_GamepadDisconnected(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_GamepadConnected(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_GamepadConnected(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                m_GamepadDisconnected: u8,
                m_GamepadConnected: u8,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let m_GamepadDisconnected: u8 =
                        unsafe { ::std::mem::transmute(m_GamepadDisconnected) };
                    m_GamepadDisconnected as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let m_GamepadConnected: u8 =
                        unsafe { ::std::mem::transmute(m_GamepadConnected) };
                    m_GamepadConnected as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Touch {
            #[doc = " Single-click, double, etc"]
            pub m_TapCount: i32,
            #[doc = " Begin, end, etc"]
            pub m_Phase: root::dmHID::Phase,
            #[doc = " Current x"]
            pub m_X: i32,
            #[doc = " Current y"]
            pub m_Y: i32,
            #[doc = " Current x, in screen space"]
            pub m_ScreenX: i32,
            #[doc = " Current y, in screen space"]
            pub m_ScreenY: i32,
            #[doc = " Current dx"]
            pub m_DX: i32,
            #[doc = " Current dy"]
            pub m_DY: i32,
            #[doc = " Current dx, in screen space"]
            pub m_ScreenDX: i32,
            #[doc = " Current dy, in screen space"]
            pub m_ScreenDY: i32,
            #[doc = " Touch id"]
            pub m_Id: i32,
        }
        #[test]
        fn bindgen_test_layout_Touch() {
            const UNINIT: ::std::mem::MaybeUninit<Touch> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Touch>(),
                44usize,
                concat!("Size of: ", stringify!(Touch))
            );
            assert_eq!(
                ::std::mem::align_of::<Touch>(),
                4usize,
                concat!("Alignment of ", stringify!(Touch))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_TapCount) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_TapCount)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Phase) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_Phase)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_X) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_X)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Y) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_Y)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenX) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_ScreenX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenY) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_ScreenY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DX) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_DX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DY) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_DY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenDX) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_ScreenDX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenDY) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_ScreenDY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Id) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Touch),
                    "::",
                    stringify!(m_Id)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID11GetKeyboardEPNS_7ContextEh"]
            pub fn GetKeyboard(context: root::dmHID::HContext, index: u8)
                -> root::dmHID::HKeyboard;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID8GetMouseEPNS_7ContextEh"]
            pub fn GetMouse(context: root::dmHID::HContext, index: u8) -> root::dmHID::HMouse;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID14GetTouchDeviceEPNS_7ContextEh"]
            pub fn GetTouchDevice(
                context: root::dmHID::HContext,
                index: u8,
            ) -> root::dmHID::HTouchDevice;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID10GetGamepadEPNS_7ContextEh"]
            pub fn GetGamepad(context: root::dmHID::HContext, index: u8) -> root::dmHID::HGamepad;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID16GetGamepadUserIdEPNS_7ContextEPNS_7GamepadEPj"]
            pub fn GetGamepadUserId(
                context: root::dmHID::HContext,
                gamepad: root::dmHID::HGamepad,
                out: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID8AddTouchEPNS_11TouchDeviceEiijNS_5PhaseE"]
            pub fn AddTouch(
                device: root::dmHID::HTouchDevice,
                x: i32,
                y: i32,
                id: u32,
                phase: root::dmHID::Phase,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID16SetGamepadButtonEPNS_7GamepadEjb"]
            pub fn SetGamepadButton(gamepad: root::dmHID::HGamepad, button: u32, value: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID14SetGamepadAxisEPNS_7GamepadEjf"]
            pub fn SetGamepadAxis(gamepad: root::dmHID::HGamepad, axis: u32, value: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID14SetMouseButtonEPNS_5MouseENS_11MouseButtonEb"]
            pub fn SetMouseButton(
                mouse: root::dmHID::HMouse,
                button: root::dmHID::MouseButton,
                value: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID16SetMousePositionEPNS_5MouseEii"]
            pub fn SetMousePosition(mouse: root::dmHID::HMouse, x: i32, y: i32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID13SetMouseWheelEPNS_5MouseEi"]
            pub fn SetMouseWheel(mouse: root::dmHID::HMouse, value: i32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID14GetMousePacketEPNS_5MouseEPNS_11MousePacketE"]
            pub fn GetMousePacket(
                mouse: root::dmHID::HMouse,
                out_packet: *mut root::dmHID::MousePacket,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID14GetMouseButtonEPNS_11MousePacketENS_11MouseButtonE"]
            pub fn GetMouseButton(
                packet: *mut root::dmHID::MousePacket,
                button: root::dmHID::MouseButton,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID6SetKeyEPNS_8KeyboardENS_3KeyEb"]
            pub fn SetKey(keyboard: root::dmHID::HKeyboard, key: root::dmHID::Key, value: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmHID15AddKeyboardCharEPNS_7ContextEi"]
            pub fn AddKeyboardChar(context: root::dmHID::HContext, chr: ::std::os::raw::c_int);
        }
        extern "C" {
            #[doc = " Obtain a gamepad packet reflecting the current input state of the gamepad in a  HID context.\n\n @param gamepad gamepad handle\n @param out_packet Gamepad packet out argument\n @return True if the packet was successfully updated."]
            #[link_name = "\u{1}_ZN5dmHID16GetGamepadPacketEPNS_7GamepadEPNS_13GamepadPacketE"]
            pub fn GetGamepadPacket(
                gamepad: root::dmHID::HGamepad,
                out_packet: *mut root::dmHID::GamepadPacket,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Convenience function to retrieve the state of a gamepad button from a gamepad packet.\n @param packet Gamepad packet\n @param button The requested button\n @return True if the button is currently pressed down."]
            #[link_name = "\u{1}_ZN5dmHID16GetGamepadButtonEPNS_13GamepadPacketEj"]
            pub fn GetGamepadButton(packet: *mut root::dmHID::GamepadPacket, button: u32) -> bool;
        }
        extern "C" {
            #[doc = " Convenience function to retrieve the state of a gamepad hat from a gamepad packet.\n @param packet Gamepad packet\n @param hat The requested hat index\n @param out_hat_value Hat value out argument\n @return True if the hat has data."]
            #[link_name = "\u{1}_ZN5dmHID13GetGamepadHatEPNS_13GamepadPacketEjPh"]
            pub fn GetGamepadHat(
                packet: *mut root::dmHID::GamepadPacket,
                hat: u32,
                out_hat_value: *mut u8,
            ) -> bool;
        }
    }
    pub mod dmTransform {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug, Copy, Clone)]
        pub struct Transform {
            pub m_Rotation: root::dmVMath::Quat,
            pub m_Translation: root::dmVMath::Vector3,
            pub m_Scale: root::dmVMath::Vector3,
        }
        #[test]
        fn bindgen_test_layout_Transform() {
            const UNINIT: ::std::mem::MaybeUninit<Transform> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Transform>(),
                48usize,
                concat!("Size of: ", stringify!(Transform))
            );
            assert_eq!(
                ::std::mem::align_of::<Transform>(),
                16usize,
                concat!("Alignment of ", stringify!(Transform))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Rotation) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transform),
                    "::",
                    stringify!(m_Rotation)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Translation) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transform),
                    "::",
                    stringify!(m_Translation)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Scale) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transform),
                    "::",
                    stringify!(m_Scale)
                )
            );
        }
    }
    pub mod dmGameObject {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub const INVALID_INSTANCE_POOL_INDEX: u32 = 4294967295;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Instance {
            _unused: [u8; 0],
        }
        pub type HInstance = *mut root::dmGameObject::Instance;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Script {
            _unused: [u8; 0],
        }
        pub type HScript = *mut root::dmGameObject::Script;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptInstance {
            _unused: [u8; 0],
        }
        pub type HScriptInstance = *mut root::dmGameObject::ScriptInstance;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Register {
            _unused: [u8; 0],
        }
        pub type HRegister = *mut root::dmGameObject::Register;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CollectionHandle {
            _unused: [u8; 0],
        }
        pub type HCollection = *mut root::dmGameObject::CollectionHandle;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyContainer {
            _unused: [u8; 0],
        }
        pub type HPropertyContainer = *mut root::dmGameObject::PropertyContainer;
        pub type HComponent = *mut ::std::os::raw::c_void;
        pub type HComponentInternal = usize;
        pub type HComponentWorld = *mut ::std::os::raw::c_void;
        pub type HCollectionDesc = *mut ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Prototype {
            _unused: [u8; 0],
        }
        pub type HPrototype = *mut root::dmGameObject::Prototype;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Properties {
            _unused: [u8; 0],
        }
        pub type HProperties = *mut root::dmGameObject::Properties;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentType {
            _unused: [u8; 0],
        }
        #[doc = "!< RESULT_OK"]
        pub const Result_RESULT_OK: root::dmGameObject::Result = 0;
        #[doc = "!< RESULT_OUT_OF_RESOURCES"]
        pub const Result_RESULT_OUT_OF_RESOURCES: root::dmGameObject::Result = -1;
        #[doc = "!< RESULT_ALREADY_REGISTERED"]
        pub const Result_RESULT_ALREADY_REGISTERED: root::dmGameObject::Result = -2;
        #[doc = "!< RESULT_IDENTIFIER_IN_USE"]
        pub const Result_RESULT_IDENTIFIER_IN_USE: root::dmGameObject::Result = -3;
        #[doc = "!< RESULT_IDENTIFIER_ALREADY_SET"]
        pub const Result_RESULT_IDENTIFIER_ALREADY_SET: root::dmGameObject::Result = -4;
        #[doc = "!< RESULT_COMPONENT_NOT_FOUND"]
        pub const Result_RESULT_COMPONENT_NOT_FOUND: root::dmGameObject::Result = -5;
        #[doc = "!< RESULT_MAXIMUM_HIEARCHICAL_DEPTH"]
        pub const Result_RESULT_MAXIMUM_HIEARCHICAL_DEPTH: root::dmGameObject::Result = -6;
        #[doc = "!< RESULT_INVALID_OPERATION"]
        pub const Result_RESULT_INVALID_OPERATION: root::dmGameObject::Result = -7;
        #[doc = "!< RESULT_COMPONENT_TYPE_NOT_FOUND"]
        pub const Result_RESULT_RESOURCE_TYPE_NOT_FOUND: root::dmGameObject::Result = -8;
        #[doc = "!< RESULT_BUFFER_OVERFLOW"]
        pub const Result_RESULT_BUFFER_OVERFLOW: root::dmGameObject::Result = -9;
        #[doc = "!< RESULT_UNKNOWN_ERROR"]
        pub const Result_RESULT_UNKNOWN_ERROR: root::dmGameObject::Result = -1000;
        pub type Result = ::std::os::raw::c_int;
        pub const PropertyType_PROPERTY_TYPE_NUMBER: root::dmGameObject::PropertyType = 0;
        pub const PropertyType_PROPERTY_TYPE_HASH: root::dmGameObject::PropertyType = 1;
        pub const PropertyType_PROPERTY_TYPE_URL: root::dmGameObject::PropertyType = 2;
        pub const PropertyType_PROPERTY_TYPE_VECTOR3: root::dmGameObject::PropertyType = 3;
        pub const PropertyType_PROPERTY_TYPE_VECTOR4: root::dmGameObject::PropertyType = 4;
        pub const PropertyType_PROPERTY_TYPE_QUAT: root::dmGameObject::PropertyType = 5;
        pub const PropertyType_PROPERTY_TYPE_BOOLEAN: root::dmGameObject::PropertyType = 6;
        pub const PropertyType_PROPERTY_TYPE_MATRIX4: root::dmGameObject::PropertyType = 7;
        pub const PropertyType_PROPERTY_TYPE_COUNT: root::dmGameObject::PropertyType = 8;
        pub type PropertyType = ::std::os::raw::c_uint;
        pub const PropertyResult_PROPERTY_RESULT_OK: root::dmGameObject::PropertyResult = 0;
        pub const PropertyResult_PROPERTY_RESULT_NOT_FOUND: root::dmGameObject::PropertyResult = -1;
        pub const PropertyResult_PROPERTY_RESULT_INVALID_FORMAT:
            root::dmGameObject::PropertyResult = -2;
        pub const PropertyResult_PROPERTY_RESULT_UNSUPPORTED_TYPE:
            root::dmGameObject::PropertyResult = -3;
        pub const PropertyResult_PROPERTY_RESULT_TYPE_MISMATCH: root::dmGameObject::PropertyResult =
            -4;
        pub const PropertyResult_PROPERTY_RESULT_COMP_NOT_FOUND:
            root::dmGameObject::PropertyResult = -5;
        pub const PropertyResult_PROPERTY_RESULT_INVALID_INSTANCE:
            root::dmGameObject::PropertyResult = -6;
        pub const PropertyResult_PROPERTY_RESULT_BUFFER_OVERFLOW:
            root::dmGameObject::PropertyResult = -7;
        pub const PropertyResult_PROPERTY_RESULT_UNSUPPORTED_VALUE:
            root::dmGameObject::PropertyResult = -8;
        pub const PropertyResult_PROPERTY_RESULT_UNSUPPORTED_OPERATION:
            root::dmGameObject::PropertyResult = -9;
        pub const PropertyResult_PROPERTY_RESULT_RESOURCE_NOT_FOUND:
            root::dmGameObject::PropertyResult = -10;
        pub const PropertyResult_PROPERTY_RESULT_INVALID_INDEX: root::dmGameObject::PropertyResult =
            -11;
        pub const PropertyResult_PROPERTY_RESULT_INVALID_KEY: root::dmGameObject::PropertyResult =
            -12;
        pub const PropertyResult_PROPERTY_RESULT_READ_ONLY: root::dmGameObject::PropertyResult =
            -13;
        pub type PropertyResult = ::std::os::raw::c_int;
        pub const Playback_PLAYBACK_NONE: root::dmGameObject::Playback = 0;
        pub const Playback_PLAYBACK_ONCE_FORWARD: root::dmGameObject::Playback = 1;
        pub const Playback_PLAYBACK_ONCE_BACKWARD: root::dmGameObject::Playback = 2;
        pub const Playback_PLAYBACK_ONCE_PINGPONG: root::dmGameObject::Playback = 3;
        pub const Playback_PLAYBACK_LOOP_FORWARD: root::dmGameObject::Playback = 4;
        pub const Playback_PLAYBACK_LOOP_BACKWARD: root::dmGameObject::Playback = 5;
        pub const Playback_PLAYBACK_LOOP_PINGPONG: root::dmGameObject::Playback = 6;
        pub const Playback_PLAYBACK_COUNT: root::dmGameObject::Playback = 7;
        pub type Playback = ::std::os::raw::c_uint;
        pub const CreateResult_CREATE_RESULT_OK: root::dmGameObject::CreateResult = 0;
        pub const CreateResult_CREATE_RESULT_UNKNOWN_ERROR: root::dmGameObject::CreateResult =
            -1000;
        pub type CreateResult = ::std::os::raw::c_int;
        pub const UpdateResult_UPDATE_RESULT_OK: root::dmGameObject::UpdateResult = 0;
        pub const UpdateResult_UPDATE_RESULT_UNKNOWN_ERROR: root::dmGameObject::UpdateResult =
            -1000;
        pub type UpdateResult = ::std::os::raw::c_int;
        pub const PropertyValueType_PROP_VALUE_ARRAY: root::dmGameObject::PropertyValueType = 0;
        pub const PropertyValueType_PROP_VALUE_HASHTABLE: root::dmGameObject::PropertyValueType = 1;
        pub type PropertyValueType = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct PropertyOptions {
            pub __bindgen_anon_1: root::dmGameObject::PropertyOptions__bindgen_ty_1,
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union PropertyOptions__bindgen_ty_1 {
            pub m_Key: root::dmhash_t,
            pub m_Index: i32,
        }
        #[test]
        fn bindgen_test_layout_PropertyOptions__bindgen_ty_1() {
            const UNINIT: ::std::mem::MaybeUninit<PropertyOptions__bindgen_ty_1> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertyOptions__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(PropertyOptions__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyOptions__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyOptions__bindgen_ty_1))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Key) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyOptions__bindgen_ty_1),
                    "::",
                    stringify!(m_Key)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Index) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyOptions__bindgen_ty_1),
                    "::",
                    stringify!(m_Index)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_PropertyOptions() {
            assert_eq!(
                ::std::mem::size_of::<PropertyOptions>(),
                16usize,
                concat!("Size of: ", stringify!(PropertyOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyOptions))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject15PropertyOptionsC1Ev"]
            pub fn PropertyOptions_PropertyOptions(this: *mut root::dmGameObject::PropertyOptions);
        }
        impl PropertyOptions {
            #[inline]
            pub fn m_HasKey(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_HasKey(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(m_HasKey: u8) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let m_HasKey: u8 = unsafe { ::std::mem::transmute(m_HasKey) };
                    m_HasKey as u64
                });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyOptions_PropertyOptions(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct PropertyVar {
            pub m_Type: root::dmGameObject::PropertyType,
            pub __bindgen_anon_1: root::dmGameObject::PropertyVar__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union PropertyVar__bindgen_ty_1 {
            pub m_Number: f64,
            pub m_Hash: root::dmhash_t,
            pub m_URL: [::std::os::raw::c_char; 32usize],
            pub m_V4: [f32; 4usize],
            pub m_M4: [f32; 16usize],
            pub m_Bool: bool,
        }
        #[test]
        fn bindgen_test_layout_PropertyVar__bindgen_ty_1() {
            const UNINIT: ::std::mem::MaybeUninit<PropertyVar__bindgen_ty_1> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertyVar__bindgen_ty_1>(),
                64usize,
                concat!("Size of: ", stringify!(PropertyVar__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyVar__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyVar__bindgen_ty_1))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Number) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar__bindgen_ty_1),
                    "::",
                    stringify!(m_Number)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Hash) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar__bindgen_ty_1),
                    "::",
                    stringify!(m_Hash)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_URL) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar__bindgen_ty_1),
                    "::",
                    stringify!(m_URL)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_V4) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar__bindgen_ty_1),
                    "::",
                    stringify!(m_V4)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_M4) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar__bindgen_ty_1),
                    "::",
                    stringify!(m_M4)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Bool) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar__bindgen_ty_1),
                    "::",
                    stringify!(m_Bool)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_PropertyVar() {
            const UNINIT: ::std::mem::MaybeUninit<PropertyVar> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertyVar>(),
                72usize,
                concat!("Size of: ", stringify!(PropertyVar))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyVar>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyVar))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyVar),
                    "::",
                    stringify!(m_Type)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1Ev"]
            pub fn PropertyVar_PropertyVar(this: *mut root::dmGameObject::PropertyVar);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1Ef"]
            pub fn PropertyVar_PropertyVar1(this: *mut root::dmGameObject::PropertyVar, v: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1Ed"]
            pub fn PropertyVar_PropertyVar2(this: *mut root::dmGameObject::PropertyVar, v: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1Em"]
            pub fn PropertyVar_PropertyVar3(
                this: *mut root::dmGameObject::PropertyVar,
                v: root::dmhash_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1ERKN9dmMessage3URLE"]
            pub fn PropertyVar_PropertyVar4(
                this: *mut root::dmGameObject::PropertyVar,
                v: *const root::dmMessage::URL,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1EN10Vectormath3Aos7Vector3E"]
            pub fn PropertyVar_PropertyVar5(
                this: *mut root::dmGameObject::PropertyVar,
                v: root::dmVMath::Vector3,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1EN10Vectormath3Aos7Vector4E"]
            pub fn PropertyVar_PropertyVar6(
                this: *mut root::dmGameObject::PropertyVar,
                v: root::dmVMath::Vector4,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1EN10Vectormath3Aos4QuatE"]
            pub fn PropertyVar_PropertyVar7(
                this: *mut root::dmGameObject::PropertyVar,
                v: root::dmVMath::Quat,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1EN10Vectormath3Aos7Matrix4E"]
            pub fn PropertyVar_PropertyVar8(
                this: *mut root::dmGameObject::PropertyVar,
                v: root::dmVMath::Matrix4,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertyVarC1Eb"]
            pub fn PropertyVar_PropertyVar9(this: *mut root::dmGameObject::PropertyVar, v: bool);
        }
        impl PropertyVar {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(v: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar1(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(v: f64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar2(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(v: root::dmhash_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar3(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(v: *const root::dmMessage::URL) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar4(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new5(v: root::dmVMath::Vector3) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar5(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new6(v: root::dmVMath::Vector4) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar6(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new7(v: root::dmVMath::Quat) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar7(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new8(v: root::dmVMath::Matrix4) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar8(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new9(v: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyVar_PropertyVar9(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
        }
        pub type GetPropertyCallback = ::std::option::Option<
            unsafe extern "C" fn(
                properties: root::dmGameObject::HProperties,
                user_data: usize,
                id: root::dmhash_t,
                out_var: *mut root::dmGameObject::PropertyVar,
            ) -> root::dmGameObject::PropertyResult,
        >;
        pub type FreeUserDataCallback =
            ::std::option::Option<unsafe extern "C" fn(user_data: usize)>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertySet {
            pub m_GetPropertyCallback: root::dmGameObject::GetPropertyCallback,
            pub m_FreeUserDataCallback: root::dmGameObject::FreeUserDataCallback,
            pub m_UserData: usize,
        }
        #[test]
        fn bindgen_test_layout_PropertySet() {
            const UNINIT: ::std::mem::MaybeUninit<PropertySet> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertySet>(),
                24usize,
                concat!("Size of: ", stringify!(PropertySet))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertySet>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertySet))
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_GetPropertyCallback) as usize - ptr as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertySet),
                    "::",
                    stringify!(m_GetPropertyCallback)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_FreeUserDataCallback) as usize - ptr as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertySet),
                    "::",
                    stringify!(m_FreeUserDataCallback)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertySet),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11PropertySetC1Ev"]
            pub fn PropertySet_PropertySet(this: *mut root::dmGameObject::PropertySet);
        }
        impl PropertySet {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertySet_PropertySet(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct PropertyDesc {
            pub m_ElementIds: [root::dmhash_t; 4usize],
            pub m_Variant: root::dmGameObject::PropertyVar,
            pub m_ValuePtr: *mut f32,
            pub _bitfield_align_1: [u16; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        #[test]
        fn bindgen_test_layout_PropertyDesc() {
            const UNINIT: ::std::mem::MaybeUninit<PropertyDesc> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PropertyDesc>(),
                120usize,
                concat!("Size of: ", stringify!(PropertyDesc))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyDesc>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyDesc))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ElementIds) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDesc),
                    "::",
                    stringify!(m_ElementIds)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Variant) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDesc),
                    "::",
                    stringify!(m_Variant)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ValuePtr) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDesc),
                    "::",
                    stringify!(m_ValuePtr)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject12PropertyDescC1Ev"]
            pub fn PropertyDesc_PropertyDesc(this: *mut root::dmGameObject::PropertyDesc);
        }
        impl PropertyDesc {
            #[inline]
            pub fn m_ReadOnly(&self) -> u16 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
            }
            #[inline]
            pub fn set_m_ReadOnly(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_ValueType(&self) -> u16 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
            }
            #[inline]
            pub fn set_m_ValueType(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_ArrayLength(&self) -> u16 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
            }
            #[inline]
            pub fn set_m_ArrayLength(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 14u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                m_ReadOnly: u16,
                m_ValueType: u16,
                m_ArrayLength: u16,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 2usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let m_ReadOnly: u16 = unsafe { ::std::mem::transmute(m_ReadOnly) };
                    m_ReadOnly as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let m_ValueType: u16 = unsafe { ::std::mem::transmute(m_ValueType) };
                    m_ValueType as u64
                });
                __bindgen_bitfield_unit.set(2usize, 14u8, {
                    let m_ArrayLength: u16 = unsafe { ::std::mem::transmute(m_ArrayLength) };
                    m_ArrayLength as u64
                });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PropertyDesc_PropertyDesc(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UpdateContext {
            pub m_TimeScale: f32,
            pub m_DT: f32,
            pub m_AccumFrameTime: f32,
            pub m_FixedUpdateFrequency: u32,
        }
        #[test]
        fn bindgen_test_layout_UpdateContext() {
            const UNINIT: ::std::mem::MaybeUninit<UpdateContext> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<UpdateContext>(),
                16usize,
                concat!("Size of: ", stringify!(UpdateContext))
            );
            assert_eq!(
                ::std::mem::align_of::<UpdateContext>(),
                4usize,
                concat!("Alignment of ", stringify!(UpdateContext))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_TimeScale) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UpdateContext),
                    "::",
                    stringify!(m_TimeScale)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DT) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UpdateContext),
                    "::",
                    stringify!(m_DT)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_AccumFrameTime) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UpdateContext),
                    "::",
                    stringify!(m_AccumFrameTime)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_FixedUpdateFrequency) as usize - ptr as usize
                },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UpdateContext),
                    "::",
                    stringify!(m_FixedUpdateFrequency)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InputAction {
            #[doc = " Action id, hashed action name"]
            pub m_ActionId: root::dmhash_t,
            #[doc = " Value of the input [0,1]"]
            pub m_Value: f32,
            #[doc = " Cursor X coordinate, in virtual screen space"]
            pub m_X: f32,
            #[doc = " Cursor Y coordinate, in virtual screen space"]
            pub m_Y: f32,
            #[doc = " Cursor dx since last frame, in virtual screen space"]
            pub m_DX: f32,
            #[doc = " Cursor dy since last frame, in virtual screen space"]
            pub m_DY: f32,
            #[doc = " Cursor X coordinate, in screen space"]
            pub m_ScreenX: f32,
            #[doc = " Cursor Y coordinate, in screen space"]
            pub m_ScreenY: f32,
            #[doc = " Cursor dx since last frame, in screen space"]
            pub m_ScreenDX: f32,
            #[doc = " Cursor dy since last frame, in screen space"]
            pub m_ScreenDY: f32,
            #[doc = " Accelerometer x value (if present)"]
            pub m_AccX: f32,
            #[doc = " Accelerometer y value (if present)"]
            pub m_AccY: f32,
            #[doc = " Accelerometer z value (if present)"]
            pub m_AccZ: f32,
            #[doc = " Touch data"]
            pub m_Touch: [root::dmHID::Touch; 11usize],
            #[doc = " Number of m_Touch"]
            pub m_TouchCount: i32,
            #[doc = " Contains text input if m_HasText, and gamepad name if m_GamepadConnected"]
            pub m_Text: [::std::os::raw::c_char; 256usize],
            pub m_TextCount: u32,
            pub m_GamepadIndex: u32,
            pub m_UserID: u32,
            pub m_GamepadPacket: root::dmHID::GamepadPacket,
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub __bindgen_padding_0: u16,
        }
        #[test]
        fn bindgen_test_layout_InputAction() {
            const UNINIT: ::std::mem::MaybeUninit<InputAction> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<InputAction>(),
                960usize,
                concat!("Size of: ", stringify!(InputAction))
            );
            assert_eq!(
                ::std::mem::align_of::<InputAction>(),
                8usize,
                concat!("Alignment of ", stringify!(InputAction))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ActionId) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_ActionId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Value) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_Value)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_X) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_X)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Y) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_Y)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DX) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_DX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_DY) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_DY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenX) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_ScreenX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenY) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_ScreenY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenDX) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_ScreenDX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ScreenDY) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_ScreenDY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_AccX) as usize - ptr as usize },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_AccX)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_AccY) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_AccY)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_AccZ) as usize - ptr as usize },
                52usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_AccZ)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Touch) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_Touch)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_TouchCount) as usize - ptr as usize },
                540usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_TouchCount)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Text) as usize - ptr as usize },
                544usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_Text)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_TextCount) as usize - ptr as usize },
                800usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_TextCount)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_GamepadIndex) as usize - ptr as usize },
                804usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_GamepadIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserID) as usize - ptr as usize },
                808usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_UserID)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_GamepadPacket) as usize - ptr as usize },
                812usize,
                concat!(
                    "Offset of field: ",
                    stringify!(InputAction),
                    "::",
                    stringify!(m_GamepadPacket)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11InputActionC1Ev"]
            pub fn InputAction_InputAction(this: *mut root::dmGameObject::InputAction);
        }
        impl InputAction {
            #[inline]
            pub fn m_IsGamepad(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_IsGamepad(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_GamepadUnknown(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_GamepadUnknown(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_GamepadDisconnected(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_GamepadDisconnected(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_GamepadConnected(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_GamepadConnected(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_HasGamepadPacket(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_HasGamepadPacket(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_HasText(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_HasText(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_Pressed(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_Pressed(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_Released(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_Released(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_Repeated(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_Repeated(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_PositionSet(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_PositionSet(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_AccelerationSet(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_AccelerationSet(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn m_Consumed(&self) -> u8 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_m_Consumed(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                m_IsGamepad: u8,
                m_GamepadUnknown: u8,
                m_GamepadDisconnected: u8,
                m_GamepadConnected: u8,
                m_HasGamepadPacket: u8,
                m_HasText: u8,
                m_Pressed: u8,
                m_Released: u8,
                m_Repeated: u8,
                m_PositionSet: u8,
                m_AccelerationSet: u8,
                m_Consumed: u8,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 2usize]> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let m_IsGamepad: u8 = unsafe { ::std::mem::transmute(m_IsGamepad) };
                    m_IsGamepad as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let m_GamepadUnknown: u8 = unsafe { ::std::mem::transmute(m_GamepadUnknown) };
                    m_GamepadUnknown as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let m_GamepadDisconnected: u8 =
                        unsafe { ::std::mem::transmute(m_GamepadDisconnected) };
                    m_GamepadDisconnected as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let m_GamepadConnected: u8 =
                        unsafe { ::std::mem::transmute(m_GamepadConnected) };
                    m_GamepadConnected as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let m_HasGamepadPacket: u8 =
                        unsafe { ::std::mem::transmute(m_HasGamepadPacket) };
                    m_HasGamepadPacket as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let m_HasText: u8 = unsafe { ::std::mem::transmute(m_HasText) };
                    m_HasText as u64
                });
                __bindgen_bitfield_unit.set(6usize, 1u8, {
                    let m_Pressed: u8 = unsafe { ::std::mem::transmute(m_Pressed) };
                    m_Pressed as u64
                });
                __bindgen_bitfield_unit.set(7usize, 1u8, {
                    let m_Released: u8 = unsafe { ::std::mem::transmute(m_Released) };
                    m_Released as u64
                });
                __bindgen_bitfield_unit.set(8usize, 1u8, {
                    let m_Repeated: u8 = unsafe { ::std::mem::transmute(m_Repeated) };
                    m_Repeated as u64
                });
                __bindgen_bitfield_unit.set(9usize, 1u8, {
                    let m_PositionSet: u8 = unsafe { ::std::mem::transmute(m_PositionSet) };
                    m_PositionSet as u64
                });
                __bindgen_bitfield_unit.set(10usize, 1u8, {
                    let m_AccelerationSet: u8 = unsafe { ::std::mem::transmute(m_AccelerationSet) };
                    m_AccelerationSet as u64
                });
                __bindgen_bitfield_unit.set(11usize, 1u8, {
                    let m_Consumed: u8 = unsafe { ::std::mem::transmute(m_Consumed) };
                    m_Consumed as u64
                });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                InputAction_InputAction(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        pub const InputResult_INPUT_RESULT_IGNORED: root::dmGameObject::InputResult = 0;
        pub const InputResult_INPUT_RESULT_CONSUMED: root::dmGameObject::InputResult = 1;
        pub const InputResult_INPUT_RESULT_UNKNOWN_ERROR: root::dmGameObject::InputResult = -1000;
        pub type InputResult = ::std::os::raw::c_int;
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject16GetMessageSocketEPNS_16CollectionHandleE"]
            pub fn GetMessageSocket(
                collection: root::dmGameObject::HCollection,
            ) -> root::dmMessage::HSocket;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject5SpawnEPNS_16CollectionHandleEPNS_9PrototypeEPKcmPNS_17PropertyContainerERKN10Vectormath3Aos6Point3ERKNS9_4QuatERKNS9_7Vector3E"]
            pub fn Spawn(
                collection: root::dmGameObject::HCollection,
                prototype: root::dmGameObject::HPrototype,
                prototype_name: *const ::std::os::raw::c_char,
                id: root::dmhash_t,
                properties: root::dmGameObject::HPropertyContainer,
                position: *const root::dmVMath::Point3,
                rotation: *const root::dmVMath::Quat,
                scale: *const root::dmVMath::Vector3,
            ) -> root::dmGameObject::HInstance;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject13GetCollectionEPNS_8InstanceE"]
            pub fn GetCollection(
                instance: root::dmGameObject::HInstance,
            ) -> root::dmGameObject::HCollection;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject3NewEPNS_16CollectionHandleEPKc"]
            pub fn New(
                collection: root::dmGameObject::HCollection,
                name: *const ::std::os::raw::c_char,
            ) -> root::dmGameObject::HInstance;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject6DeleteEPNS_16CollectionHandleEPNS_8InstanceEb"]
            pub fn Delete(
                collection: root::dmGameObject::HCollection,
                instance: root::dmGameObject::HInstance,
                recursive: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject19ConstructInstanceIdEj"]
            pub fn ConstructInstanceId(index: u32) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject20AcquireInstanceIndexEPNS_16CollectionHandleE"]
            pub fn AcquireInstanceIndex(collection: root::dmGameObject::HCollection) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject19AssignInstanceIndexEjPNS_8InstanceE"]
            pub fn AssignInstanceIndex(index: u32, instance: root::dmGameObject::HInstance);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject13GetIdentifierEPNS_8InstanceE"]
            pub fn GetIdentifier(instance: root::dmGameObject::HInstance) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject13SetIdentifierEPNS_16CollectionHandleEPNS_8InstanceEm"]
            pub fn SetIdentifier(
                collection: root::dmGameObject::HCollection,
                instance: root::dmGameObject::HInstance,
                identifier: root::dmhash_t,
            ) -> root::dmGameObject::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject25GetInstanceFromIdentifierEPNS_16CollectionHandleEm"]
            pub fn GetInstanceFromIdentifier(
                collection: root::dmGameObject::HCollection,
                identifier: root::dmhash_t,
            ) -> root::dmGameObject::HInstance;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject14GetComponentIdEPNS_8InstanceEtPm"]
            pub fn GetComponentId(
                instance: root::dmGameObject::HInstance,
                component_index: u16,
                component_id: *mut root::dmhash_t,
            ) -> root::dmGameObject::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject12GetComponentEPNS_8InstanceEmPjPPvS4_"]
            pub fn GetComponent(
                instance: root::dmGameObject::HInstance,
                component_id: root::dmhash_t,
                component_type: *mut u32,
                component: *mut root::dmGameObject::HComponent,
                out_world: *mut root::dmGameObject::HComponentWorld,
            ) -> root::dmGameObject::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11SetPositionEPNS_8InstanceEN10Vectormath3Aos6Point3E"]
            pub fn SetPosition(
                instance: root::dmGameObject::HInstance,
                position: root::dmVMath::Point3,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11GetPositionEPNS_8InstanceE"]
            pub fn GetPosition(instance: root::dmGameObject::HInstance) -> root::dmVMath::Point3;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11SetRotationEPNS_8InstanceEN10Vectormath3Aos4QuatE"]
            pub fn SetRotation(
                instance: root::dmGameObject::HInstance,
                rotation: root::dmVMath::Quat,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11GetRotationEPNS_8InstanceE"]
            pub fn GetRotation(instance: root::dmGameObject::HInstance) -> root::dmVMath::Quat;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject8SetScaleEPNS_8InstanceEf"]
            pub fn SetScale(instance: root::dmGameObject::HInstance, scale: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject8SetScaleEPNS_8InstanceEN10Vectormath3Aos7Vector3E"]
            pub fn SetScale1(
                instance: root::dmGameObject::HInstance,
                scale: root::dmVMath::Vector3,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject15GetUniformScaleEPNS_8InstanceE"]
            pub fn GetUniformScale(instance: root::dmGameObject::HInstance) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject8GetScaleEPNS_8InstanceE"]
            pub fn GetScale(instance: root::dmGameObject::HInstance) -> root::dmVMath::Vector3;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject16GetWorldPositionEPNS_8InstanceE"]
            pub fn GetWorldPosition(
                instance: root::dmGameObject::HInstance,
            ) -> root::dmVMath::Point3;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject16GetWorldRotationEPNS_8InstanceE"]
            pub fn GetWorldRotation(instance: root::dmGameObject::HInstance)
                -> root::dmVMath::Quat;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject13GetWorldScaleEPNS_8InstanceE"]
            pub fn GetWorldScale(instance: root::dmGameObject::HInstance)
                -> root::dmVMath::Vector3;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject20GetWorldUniformScaleEPNS_8InstanceE"]
            pub fn GetWorldUniformScale(instance: root::dmGameObject::HInstance) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject14GetWorldMatrixEPNS_8InstanceE"]
            pub fn GetWorldMatrix(
                instance: root::dmGameObject::HInstance,
            ) -> *const root::dmVMath::Matrix4;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject17GetWorldTransformEPNS_8InstanceE"]
            pub fn GetWorldTransform(
                instance: root::dmGameObject::HInstance,
            ) -> root::dmTransform::Transform;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject7SetBoneEPNS_8InstanceEb"]
            pub fn SetBone(instance: root::dmGameObject::HInstance, bone: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject6IsBoneEPNS_8InstanceE"]
            pub fn IsBone(instance: root::dmGameObject::HInstance) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject17SetBoneTransformsEPNS_8InstanceERN11dmTransform9TransformEPS3_j"]
            pub fn SetBoneTransforms(
                instance: root::dmGameObject::HInstance,
                component_transform: *mut root::dmTransform::Transform,
                transforms: *mut root::dmTransform::Transform,
                transform_count: u32,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject11DeleteBonesEPNS_8InstanceE"]
            pub fn DeleteBones(parent: root::dmGameObject::HInstance);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject9SetParentEPNS_8InstanceES1_"]
            pub fn SetParent(
                child: root::dmGameObject::HInstance,
                parent: root::dmGameObject::HInstance,
            ) -> root::dmGameObject::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject9GetParentEPNS_8InstanceE"]
            pub fn GetParent(
                instance: root::dmGameObject::HInstance,
            ) -> root::dmGameObject::HInstance;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject21GetComponentTypeIndexEPNS_16CollectionHandleEm"]
            pub fn GetComponentTypeIndex(
                collection: root::dmGameObject::HCollection,
                type_hash: root::dmhash_t,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject8GetWorldEPNS_16CollectionHandleEj"]
            pub fn GetWorld(
                collection: root::dmGameObject::HCollection,
                component_type_index: u32,
            ) -> root::dmGameObject::HComponentWorld;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject10GetContextEPNS_16CollectionHandleEj"]
            pub fn GetContext(
                collection: root::dmGameObject::HCollection,
                component_type_index: u32,
            ) -> *mut ::std::os::raw::c_void;
        }
        pub type FIteratorChildren = ::std::option::Option<
            unsafe extern "C" fn(
                it: *mut root::dmGameObject::SceneNodeIterator,
                node: *mut root::dmGameObject::SceneNode,
            ),
        >;
        pub type FIteratorNext = ::std::option::Option<
            unsafe extern "C" fn(it: *mut root::dmGameObject::SceneNodeIterator) -> bool,
        >;
        pub const SceneNodeType_SCENE_NODE_TYPE_COLLECTION: root::dmGameObject::SceneNodeType = 0;
        pub const SceneNodeType_SCENE_NODE_TYPE_GAMEOBJECT: root::dmGameObject::SceneNodeType = 1;
        pub const SceneNodeType_SCENE_NODE_TYPE_COMPONENT: root::dmGameObject::SceneNodeType = 2;
        pub const SceneNodeType_SCENE_NODE_TYPE_SUBCOMPONENT: root::dmGameObject::SceneNodeType = 3;
        #[doc = " scene node types\n @enum\n @name SceneNodeType\n @member dmGameObject::SCENE_NODE_TYPE_COLLECTION\n @member dmGameObject::SCENE_NODE_TYPE_GAMEOBJECT\n @member dmGameObject::SCENE_NODE_TYPE_COMPONENT\n @member dmGameObject::SCENE_NODE_TYPE_SUBCOMPONENT"]
        pub type SceneNodeType = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SceneNode {
            pub m_Node: u64,
            pub m_Type: root::dmGameObject::SceneNodeType,
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_ComponentType: *mut root::dmGameObject::ComponentType,
            pub m_ComponentPrototype: *mut ::std::os::raw::c_void,
            pub m_ComponentWorld: *mut ::std::os::raw::c_void,
            pub m_Component: usize,
        }
        #[test]
        fn bindgen_test_layout_SceneNode() {
            const UNINIT: ::std::mem::MaybeUninit<SceneNode> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SceneNode>(),
                64usize,
                concat!("Size of: ", stringify!(SceneNode))
            );
            assert_eq!(
                ::std::mem::align_of::<SceneNode>(),
                8usize,
                concat!("Alignment of ", stringify!(SceneNode))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Node) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_Node)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_Type)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ComponentType) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_ComponentType)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_ComponentPrototype) as usize - ptr as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_ComponentPrototype)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ComponentWorld) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_ComponentWorld)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Component) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNode),
                    "::",
                    stringify!(m_Component)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SceneNodeIterator {
            pub m_Node: root::dmGameObject::SceneNode,
            pub m_Parent: root::dmGameObject::SceneNode,
            pub m_NextChild: root::dmGameObject::SceneNode,
            pub m_FnIterateNext: root::dmGameObject::FIteratorNext,
        }
        #[test]
        fn bindgen_test_layout_SceneNodeIterator() {
            const UNINIT: ::std::mem::MaybeUninit<SceneNodeIterator> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SceneNodeIterator>(),
                200usize,
                concat!("Size of: ", stringify!(SceneNodeIterator))
            );
            assert_eq!(
                ::std::mem::align_of::<SceneNodeIterator>(),
                8usize,
                concat!("Alignment of ", stringify!(SceneNodeIterator))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Node) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeIterator),
                    "::",
                    stringify!(m_Node)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Parent) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeIterator),
                    "::",
                    stringify!(m_Parent)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_NextChild) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeIterator),
                    "::",
                    stringify!(m_NextChild)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_FnIterateNext) as usize - ptr as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeIterator),
                    "::",
                    stringify!(m_FnIterateNext)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject15TraverseGetRootEPNS_8RegisterEPNS_9SceneNodeE"]
            pub fn TraverseGetRoot(
                regist: root::dmGameObject::HRegister,
                node: *mut root::dmGameObject::SceneNode,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject23TraverseIterateChildrenEPNS_9SceneNodeE"]
            pub fn TraverseIterateChildren(
                node: *mut root::dmGameObject::SceneNode,
            ) -> root::dmGameObject::SceneNodeIterator;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject19TraverseIterateNextEPNS_17SceneNodeIteratorE"]
            pub fn TraverseIterateNext(it: *mut root::dmGameObject::SceneNodeIterator) -> bool;
        }
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_NUMBER:
            root::dmGameObject::SceneNodePropertyType = 0;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_HASH:
            root::dmGameObject::SceneNodePropertyType = 1;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_URL:
            root::dmGameObject::SceneNodePropertyType = 2;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_VECTOR3:
            root::dmGameObject::SceneNodePropertyType = 3;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_VECTOR4:
            root::dmGameObject::SceneNodePropertyType = 4;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_QUAT:
            root::dmGameObject::SceneNodePropertyType = 5;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_BOOLEAN:
            root::dmGameObject::SceneNodePropertyType = 6;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_TEXT:
            root::dmGameObject::SceneNodePropertyType = 7;
        pub const SceneNodePropertyType_SCENE_NODE_PROPERTY_TYPE_COUNT:
            root::dmGameObject::SceneNodePropertyType = 8;
        pub type SceneNodePropertyType = ::std::os::raw::c_uint;
        pub type FIteratorProperties = ::std::option::Option<
            unsafe extern "C" fn(
                it: *mut root::dmGameObject::SceneNodePropertyIterator,
                node: *mut root::dmGameObject::SceneNode,
            ),
        >;
        pub type FIteratorPropertiesNext = ::std::option::Option<
            unsafe extern "C" fn(it: *mut root::dmGameObject::SceneNodePropertyIterator) -> bool,
        >;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct SceneNodeProperty {
            pub m_NameHash: root::dmhash_t,
            pub m_Type: root::dmGameObject::SceneNodePropertyType,
            pub m_Value: root::dmGameObject::SceneNodeProperty__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union SceneNodeProperty__bindgen_ty_1 {
            pub m_Number: f64,
            pub m_Hash: root::dmhash_t,
            pub m_URL: [::std::os::raw::c_char; 1024usize],
            pub m_V4: [f32; 4usize],
            pub m_Bool: bool,
            pub m_Text: *const ::std::os::raw::c_char,
        }
        #[test]
        fn bindgen_test_layout_SceneNodeProperty__bindgen_ty_1() {
            const UNINIT: ::std::mem::MaybeUninit<SceneNodeProperty__bindgen_ty_1> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SceneNodeProperty__bindgen_ty_1>(),
                1024usize,
                concat!("Size of: ", stringify!(SceneNodeProperty__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<SceneNodeProperty__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(SceneNodeProperty__bindgen_ty_1))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Number) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty__bindgen_ty_1),
                    "::",
                    stringify!(m_Number)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Hash) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty__bindgen_ty_1),
                    "::",
                    stringify!(m_Hash)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_URL) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty__bindgen_ty_1),
                    "::",
                    stringify!(m_URL)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_V4) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty__bindgen_ty_1),
                    "::",
                    stringify!(m_V4)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Bool) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty__bindgen_ty_1),
                    "::",
                    stringify!(m_Bool)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Text) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty__bindgen_ty_1),
                    "::",
                    stringify!(m_Text)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_SceneNodeProperty() {
            const UNINIT: ::std::mem::MaybeUninit<SceneNodeProperty> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SceneNodeProperty>(),
                1040usize,
                concat!("Size of: ", stringify!(SceneNodeProperty))
            );
            assert_eq!(
                ::std::mem::align_of::<SceneNodeProperty>(),
                8usize,
                concat!("Alignment of ", stringify!(SceneNodeProperty))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_NameHash) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty),
                    "::",
                    stringify!(m_NameHash)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty),
                    "::",
                    stringify!(m_Type)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Value) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodeProperty),
                    "::",
                    stringify!(m_Value)
                )
            );
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct SceneNodePropertyIterator {
            pub m_Property: root::dmGameObject::SceneNodeProperty,
            pub m_Node: *mut root::dmGameObject::SceneNode,
            pub m_Next: u64,
            pub m_FnIterateNext: root::dmGameObject::FIteratorPropertiesNext,
        }
        #[test]
        fn bindgen_test_layout_SceneNodePropertyIterator() {
            const UNINIT: ::std::mem::MaybeUninit<SceneNodePropertyIterator> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<SceneNodePropertyIterator>(),
                1064usize,
                concat!("Size of: ", stringify!(SceneNodePropertyIterator))
            );
            assert_eq!(
                ::std::mem::align_of::<SceneNodePropertyIterator>(),
                8usize,
                concat!("Alignment of ", stringify!(SceneNodePropertyIterator))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Property) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodePropertyIterator),
                    "::",
                    stringify!(m_Property)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Node) as usize - ptr as usize },
                1040usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodePropertyIterator),
                    "::",
                    stringify!(m_Node)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Next) as usize - ptr as usize },
                1048usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodePropertyIterator),
                    "::",
                    stringify!(m_Next)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_FnIterateNext) as usize - ptr as usize },
                1056usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SceneNodePropertyIterator),
                    "::",
                    stringify!(m_FnIterateNext)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject25TraverseIteratePropertiesEPNS_9SceneNodeE"]
            pub fn TraverseIterateProperties(
                node: *mut root::dmGameObject::SceneNode,
            ) -> root::dmGameObject::SceneNodePropertyIterator;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject29TraverseIteratePropertiesNextEPNS_25SceneNodePropertyIteratorE"]
            pub fn TraverseIteratePropertiesNext(
                it: *mut root::dmGameObject::SceneNodePropertyIterator,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject17PostScriptMessageEPKN5dmDDF10DescriptorEPKhjPKN9dmMessage3URLES9_ib"]
            pub fn PostScriptMessage(
                descriptor: *const root::dmDDF::Descriptor,
                payload: *const u8,
                payload_size: u32,
                sender: *const root::dmMessage::URL,
                receiver: *const root::dmMessage::URL,
                function_ref: ::std::os::raw::c_int,
                unref_function_after_call: bool,
            ) -> root::dmGameObject::Result;
        }
        pub type HComponentType = *mut root::dmGameObject::ComponentType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentNewWorldParams {
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_ComponentIndex: u8,
            pub m_MaxInstances: u32,
            pub m_World: *mut *mut ::std::os::raw::c_void,
            pub m_MaxComponentInstances: u32,
        }
        #[test]
        fn bindgen_test_layout_ComponentNewWorldParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentNewWorldParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentNewWorldParams>(),
                32usize,
                concat!("Size of: ", stringify!(ComponentNewWorldParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentNewWorldParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentNewWorldParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentNewWorldParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ComponentIndex) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentNewWorldParams),
                    "::",
                    stringify!(m_ComponentIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_MaxInstances) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentNewWorldParams),
                    "::",
                    stringify!(m_MaxInstances)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentNewWorldParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe {
                    ::std::ptr::addr_of!((*ptr).m_MaxComponentInstances) as usize - ptr as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentNewWorldParams),
                    "::",
                    stringify!(m_MaxComponentInstances)
                )
            );
        }
        pub type ComponentNewWorld = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentNewWorldParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentDeleteWorldParams {
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_World: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_ComponentDeleteWorldParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentDeleteWorldParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentDeleteWorldParams>(),
                16usize,
                concat!("Size of: ", stringify!(ComponentDeleteWorldParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentDeleteWorldParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentDeleteWorldParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDeleteWorldParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDeleteWorldParams),
                    "::",
                    stringify!(m_World)
                )
            );
        }
        pub type ComponentDeleteWorld = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentDeleteWorldParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentCreateParams {
            pub m_Instance: root::dmGameObject::HInstance,
            pub __bindgen_padding_0: u64,
            pub m_Position: root::dmVMath::Point3,
            pub m_Rotation: root::dmVMath::Quat,
            pub m_Scale: root::dmVMath::Vector3,
            pub m_PropertySet: root::dmGameObject::PropertySet,
            pub m_Resource: *mut ::std::os::raw::c_void,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
            pub m_ComponentIndex: u16,
        }
        #[test]
        fn bindgen_test_layout_ComponentCreateParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentCreateParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentCreateParams>(),
                128usize,
                concat!("Size of: ", stringify!(ComponentCreateParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentCreateParams>(),
                16usize,
                concat!("Alignment of ", stringify!(ComponentCreateParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Position) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_Position)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Rotation) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_Rotation)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Scale) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_Scale)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PropertySet) as usize - ptr as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_PropertySet)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_Resource)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_ComponentIndex) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentCreateParams),
                    "::",
                    stringify!(m_ComponentIndex)
                )
            );
        }
        pub type ComponentCreate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentCreateParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentDestroyParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentDestroyParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentDestroyParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentDestroyParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentDestroyParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentDestroyParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentDestroyParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDestroyParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDestroyParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDestroyParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDestroyParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentDestroyParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentDestroy = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentDestroyParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentInitParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentInitParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentInitParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentInitParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentInitParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentInitParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentInitParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentInitParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentInitParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentInitParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentInitParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentInitParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentInit = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentInitParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentFinalParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentFinalParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentFinalParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentFinalParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentFinalParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentFinalParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentFinalParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentFinalParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentFinalParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentFinalParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentFinalParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentFinalParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentFinal = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentFinalParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentAddToUpdateParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentAddToUpdateParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentAddToUpdateParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentAddToUpdateParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentAddToUpdateParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentAddToUpdateParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentAddToUpdateParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentAddToUpdateParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentAddToUpdateParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentAddToUpdateParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentAddToUpdateParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentAddToUpdateParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentAddToUpdate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentAddToUpdateParams,
            ) -> root::dmGameObject::CreateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentGetParams {
            pub m_World: root::dmGameObject::HComponentWorld,
            pub m_UserData: root::dmGameObject::HComponentInternal,
        }
        #[test]
        fn bindgen_test_layout_ComponentGetParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentGetParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentGetParams>(),
                16usize,
                concat!("Size of: ", stringify!(ComponentGetParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentGetParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentGetParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentGet = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentGetParams,
            ) -> *mut ::std::os::raw::c_void,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentsUpdateParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_UpdateContext: *const root::dmGameObject::UpdateContext,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_ComponentsUpdateParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentsUpdateParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentsUpdateParams>(),
                32usize,
                concat!("Size of: ", stringify!(ComponentsUpdateParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentsUpdateParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentsUpdateParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsUpdateParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UpdateContext) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsUpdateParams),
                    "::",
                    stringify!(m_UpdateContext)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsUpdateParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsUpdateParams),
                    "::",
                    stringify!(m_Context)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentsUpdateResult {
            pub m_TransformsUpdated: bool,
        }
        #[test]
        fn bindgen_test_layout_ComponentsUpdateResult() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentsUpdateResult> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentsUpdateResult>(),
                1usize,
                concat!("Size of: ", stringify!(ComponentsUpdateResult))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentsUpdateResult>(),
                1usize,
                concat!("Alignment of ", stringify!(ComponentsUpdateResult))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_TransformsUpdated) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsUpdateResult),
                    "::",
                    stringify!(m_TransformsUpdated)
                )
            );
        }
        pub type ComponentsUpdate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentsUpdateParams,
                result: *mut root::dmGameObject::ComponentsUpdateResult,
            ) -> root::dmGameObject::UpdateResult,
        >;
        pub type ComponentsFixedUpdate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentsUpdateParams,
                result: *mut root::dmGameObject::ComponentsUpdateResult,
            ) -> root::dmGameObject::UpdateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentsRenderParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_ComponentsRenderParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentsRenderParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentsRenderParams>(),
                24usize,
                concat!("Size of: ", stringify!(ComponentsRenderParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentsRenderParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentsRenderParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsRenderParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsRenderParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsRenderParams),
                    "::",
                    stringify!(m_Context)
                )
            );
        }
        pub type ComponentsRender = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentsRenderParams,
            ) -> root::dmGameObject::UpdateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentsPostUpdateParams {
            pub m_Collection: root::dmGameObject::HCollection,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_ComponentsPostUpdateParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentsPostUpdateParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentsPostUpdateParams>(),
                24usize,
                concat!("Size of: ", stringify!(ComponentsPostUpdateParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentsPostUpdateParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentsPostUpdateParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Collection) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsPostUpdateParams),
                    "::",
                    stringify!(m_Collection)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsPostUpdateParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentsPostUpdateParams),
                    "::",
                    stringify!(m_Context)
                )
            );
        }
        pub type ComponentsPostUpdate = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentsPostUpdateParams,
            ) -> root::dmGameObject::UpdateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentOnMessageParams {
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
            pub m_Message: *mut root::dmMessage::Message,
        }
        #[test]
        fn bindgen_test_layout_ComponentOnMessageParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentOnMessageParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentOnMessageParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentOnMessageParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentOnMessageParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentOnMessageParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnMessageParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnMessageParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnMessageParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnMessageParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Message) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnMessageParams),
                    "::",
                    stringify!(m_Message)
                )
            );
        }
        pub type ComponentOnMessage = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentOnMessageParams,
            ) -> root::dmGameObject::UpdateResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentOnInputParams {
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_InputAction: *const root::dmGameObject::InputAction,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentOnInputParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentOnInputParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentOnInputParams>(),
                32usize,
                concat!("Size of: ", stringify!(ComponentOnInputParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentOnInputParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentOnInputParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnInputParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_InputAction) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnInputParams),
                    "::",
                    stringify!(m_InputAction)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnInputParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnInputParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentOnInput = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentOnInputParams,
            ) -> root::dmGameObject::InputResult,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentOnReloadParams {
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_Resource: *mut ::std::os::raw::c_void,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentOnReloadParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentOnReloadParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentOnReloadParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentOnReloadParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentOnReloadParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentOnReloadParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnReloadParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Resource) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnReloadParams),
                    "::",
                    stringify!(m_Resource)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnReloadParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnReloadParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentOnReloadParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentOnReload = ::std::option::Option<
            unsafe extern "C" fn(params: *const root::dmGameObject::ComponentOnReloadParams),
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentSetPropertiesParams {
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_PropertySet: root::dmGameObject::PropertySet,
            pub m_UserData: *mut usize,
        }
        #[test]
        fn bindgen_test_layout_ComponentSetPropertiesParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentSetPropertiesParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentSetPropertiesParams>(),
                40usize,
                concat!("Size of: ", stringify!(ComponentSetPropertiesParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentSetPropertiesParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentSetPropertiesParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertiesParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PropertySet) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertiesParams),
                    "::",
                    stringify!(m_PropertySet)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertiesParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
        }
        pub type ComponentSetProperties = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentSetPropertiesParams,
            ) -> root::dmGameObject::PropertyResult,
        >;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ComponentGetPropertyParams {
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_PropertyId: root::dmhash_t,
            pub m_UserData: *mut usize,
            pub m_Options: root::dmGameObject::PropertyOptions,
        }
        #[test]
        fn bindgen_test_layout_ComponentGetPropertyParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentGetPropertyParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentGetPropertyParams>(),
                56usize,
                concat!("Size of: ", stringify!(ComponentGetPropertyParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentGetPropertyParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentGetPropertyParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetPropertyParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetPropertyParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetPropertyParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PropertyId) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetPropertyParams),
                    "::",
                    stringify!(m_PropertyId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetPropertyParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Options) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentGetPropertyParams),
                    "::",
                    stringify!(m_Options)
                )
            );
        }
        pub type ComponentGetProperty = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentGetPropertyParams,
                out_value: *mut root::dmGameObject::PropertyDesc,
            ) -> root::dmGameObject::PropertyResult,
        >;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct ComponentSetPropertyParams {
            pub m_Context: *mut ::std::os::raw::c_void,
            pub m_World: *mut ::std::os::raw::c_void,
            pub m_Instance: root::dmGameObject::HInstance,
            pub m_PropertyId: root::dmhash_t,
            pub m_UserData: *mut usize,
            pub m_Value: root::dmGameObject::PropertyVar,
            pub m_Options: root::dmGameObject::PropertyOptions,
        }
        #[test]
        fn bindgen_test_layout_ComponentSetPropertyParams() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentSetPropertyParams> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentSetPropertyParams>(),
                128usize,
                concat!("Size of: ", stringify!(ComponentSetPropertyParams))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentSetPropertyParams>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentSetPropertyParams))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Context) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_Context)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_World) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_World)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Instance) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_Instance)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_PropertyId) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_PropertyId)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UserData) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_UserData)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Value) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_Value)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Options) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentSetPropertyParams),
                    "::",
                    stringify!(m_Options)
                )
            );
        }
        pub type ComponentSetProperty = ::std::option::Option<
            unsafe extern "C" fn(
                params: *const root::dmGameObject::ComponentSetPropertyParams,
            ) -> root::dmGameObject::PropertyResult,
        >;
        pub type ComponentIterProperties = ::std::option::Option<
            unsafe extern "C" fn(
                pit: *mut root::dmGameObject::SceneNodePropertyIterator,
                node: *mut root::dmGameObject::SceneNode,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject25ComponentTypeGetTypeIndexEPNS_13ComponentTypeE"]
            pub fn ComponentTypeGetTypeIndex(type_: root::dmGameObject::HComponentType) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject26ComponentTypeSetNewWorldFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_23ComponentNewWorldParamsEE"]
            pub fn ComponentTypeSetNewWorldFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentNewWorld,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject29ComponentTypeSetDeleteWorldFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_26ComponentDeleteWorldParamsEE"]
            pub fn ComponentTypeSetDeleteWorldFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentDeleteWorld,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject24ComponentTypeSetCreateFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_21ComponentCreateParamsEE"]
            pub fn ComponentTypeSetCreateFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentCreate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject25ComponentTypeSetDestroyFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_22ComponentDestroyParamsEE"]
            pub fn ComponentTypeSetDestroyFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentDestroy,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject22ComponentTypeSetInitFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_19ComponentInitParamsEE"]
            pub fn ComponentTypeSetInitFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentInit,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject23ComponentTypeSetFinalFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_20ComponentFinalParamsEE"]
            pub fn ComponentTypeSetFinalFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentFinal,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject29ComponentTypeSetAddToUpdateFnEPNS_13ComponentTypeEPFNS_12CreateResultERKNS_26ComponentAddToUpdateParamsEE"]
            pub fn ComponentTypeSetAddToUpdateFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentAddToUpdate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject21ComponentTypeSetGetFnEPNS_13ComponentTypeEPFPvRKNS_18ComponentGetParamsEE"]
            pub fn ComponentTypeSetGetFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentGet,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject24ComponentTypeSetRenderFnEPNS_13ComponentTypeEPFNS_12UpdateResultERKNS_22ComponentsRenderParamsEE"]
            pub fn ComponentTypeSetRenderFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentsRender,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject24ComponentTypeSetUpdateFnEPNS_13ComponentTypeEPFNS_12UpdateResultERKNS_22ComponentsUpdateParamsERNS_22ComponentsUpdateResultEE"]
            pub fn ComponentTypeSetUpdateFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentsUpdate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject29ComponentTypeSetFixedUpdateFnEPNS_13ComponentTypeEPFNS_12UpdateResultERKNS_22ComponentsUpdateParamsERNS_22ComponentsUpdateResultEE"]
            pub fn ComponentTypeSetFixedUpdateFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentsFixedUpdate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject28ComponentTypeSetPostUpdateFnEPNS_13ComponentTypeEPFNS_12UpdateResultERKNS_26ComponentsPostUpdateParamsEE"]
            pub fn ComponentTypeSetPostUpdateFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentsPostUpdate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject27ComponentTypeSetOnMessageFnEPNS_13ComponentTypeEPFNS_12UpdateResultERKNS_24ComponentOnMessageParamsEE"]
            pub fn ComponentTypeSetOnMessageFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentOnMessage,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject25ComponentTypeSetOnInputFnEPNS_13ComponentTypeEPFNS_11InputResultERKNS_22ComponentOnInputParamsEE"]
            pub fn ComponentTypeSetOnInputFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentOnInput,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject26ComponentTypeSetOnReloadFnEPNS_13ComponentTypeEPFvRKNS_23ComponentOnReloadParamsEE"]
            pub fn ComponentTypeSetOnReloadFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentOnReload,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject31ComponentTypeSetSetPropertiesFnEPNS_13ComponentTypeEPFNS_14PropertyResultERKNS_28ComponentSetPropertiesParamsEE"]
            pub fn ComponentTypeSetSetPropertiesFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentSetProperties,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject29ComponentTypeSetGetPropertyFnEPNS_13ComponentTypeEPFNS_14PropertyResultERKNS_26ComponentGetPropertyParamsERNS_12PropertyDescEE"]
            pub fn ComponentTypeSetGetPropertyFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentGetProperty,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject29ComponentTypeSetSetPropertyFnEPNS_13ComponentTypeEPFNS_14PropertyResultERKNS_26ComponentSetPropertyParamsEE"]
            pub fn ComponentTypeSetSetPropertyFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::ComponentSetProperty,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject23ComponentTypeSetContextEPNS_13ComponentTypeEPv"]
            pub fn ComponentTypeSetContext(
                type_: root::dmGameObject::HComponentType,
                context: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject23ComponentTypeGetContextEPNS_13ComponentTypeE"]
            pub fn ComponentTypeGetContext(
                type_: root::dmGameObject::HComponentType,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject31ComponentTypeSetReadsTransformsEPNS_13ComponentTypeEb"]
            pub fn ComponentTypeSetReadsTransforms(
                type_: root::dmGameObject::HComponentType,
                reads_transforms: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject20ComponentTypeSetPrioEPNS_13ComponentTypeEt"]
            pub fn ComponentTypeSetPrio(type_: root::dmGameObject::HComponentType, prio: u16);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject27ComponentTypeSetHasUserDataEPNS_13ComponentTypeEb"]
            pub fn ComponentTypeSetHasUserData(
                type_: root::dmGameObject::HComponentType,
                has_user_data: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject31ComponentTypeSetChildIteratorFnEPNS_13ComponentTypeEPFvPNS_17SceneNodeIteratorEPNS_9SceneNodeEE"]
            pub fn ComponentTypeSetChildIteratorFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::FIteratorChildren,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN12dmGameObject34ComponentTypeSetPropertyIteratorFnEPNS_13ComponentTypeEPFvPNS_25SceneNodePropertyIteratorEPNS_9SceneNodeEE"]
            pub fn ComponentTypeSetPropertyIteratorFn(
                type_: root::dmGameObject::HComponentType,
                fn_: root::dmGameObject::FIteratorProperties,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentTypeCreateCtx {
            pub m_Config: root::dmConfigFile::HConfig,
            pub m_Factory: root::dmResource::HFactory,
            pub m_Register: root::dmGameObject::HRegister,
            pub m_Script: root::dmScript::HContext,
            pub m_Contexts: root::dmHashTable64<*mut ::std::os::raw::c_void>,
        }
        #[test]
        fn bindgen_test_layout_ComponentTypeCreateCtx() {
            const UNINIT: ::std::mem::MaybeUninit<ComponentTypeCreateCtx> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ComponentTypeCreateCtx>(),
                88usize,
                concat!("Size of: ", stringify!(ComponentTypeCreateCtx))
            );
            assert_eq!(
                ::std::mem::align_of::<ComponentTypeCreateCtx>(),
                8usize,
                concat!("Alignment of ", stringify!(ComponentTypeCreateCtx))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Config) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentTypeCreateCtx),
                    "::",
                    stringify!(m_Config)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Factory) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentTypeCreateCtx),
                    "::",
                    stringify!(m_Factory)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Register) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentTypeCreateCtx),
                    "::",
                    stringify!(m_Register)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Script) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentTypeCreateCtx),
                    "::",
                    stringify!(m_Script)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Contexts) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ComponentTypeCreateCtx),
                    "::",
                    stringify!(m_Contexts)
                )
            );
        }
        pub type ComponentTypeCreateFunction = ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *const root::dmGameObject::ComponentTypeCreateCtx,
                type_: root::dmGameObject::HComponentType,
            ) -> root::dmGameObject::Result,
        >;
        pub type ComponentTypeDestroyFunction = ::std::option::Option<
            unsafe extern "C" fn(
                ctx: *const root::dmGameObject::ComponentTypeCreateCtx,
                type_: root::dmGameObject::HComponentType,
            ) -> root::dmGameObject::Result,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ComponentTypeDescriptor {
            _unused: [u8; 0],
        }
        extern "C" {
            #[doc = " Register a new component type (Internal)\n @param regist Gameobject register\n @param type Collection of component type registration data\n @return RESULT_OK on success"]
            #[link_name = "\u{1}_ZN12dmGameObject31RegisterComponentTypeDescriptorEPNS_23ComponentTypeDescriptorEPKcPFNS_6ResultEPKNS_22ComponentTypeCreateCtxEPNS_13ComponentTypeEESB_"]
            pub fn RegisterComponentTypeDescriptor(
                desc: *mut root::dmGameObject::ComponentTypeDescriptor,
                name: *const ::std::os::raw::c_char,
                create_fn: root::dmGameObject::ComponentTypeCreateFunction,
                destroy_fn: root::dmGameObject::ComponentTypeDestroyFunction,
            ) -> root::dmGameObject::Result;
        }
        #[doc = " Component type desc bytesize declaration. Internal"]
        pub const s_ComponentTypeDescBufferSize: usize = 128;
    }
    pub mod dmEngine {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN8dmEngine13GetConfigFileEP18ExtensionAppParams"]
            pub fn GetConfigFile(
                app_params: *mut root::dmExtension::AppParams,
            ) -> root::dmConfigFile::HConfig;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmEngine12GetWebServerEP18ExtensionAppParams"]
            pub fn GetWebServer(
                app_params: *mut root::dmExtension::AppParams,
            ) -> root::dmWebServer::HServer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmEngine21GetGameObjectRegisterEP18ExtensionAppParams"]
            pub fn GetGameObjectRegister(
                app_params: *mut root::dmExtension::AppParams,
            ) -> root::dmGameObject::HRegister;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmEngine13GetHIDContextEP18ExtensionAppParams"]
            pub fn GetHIDContext(
                app_params: *mut root::dmExtension::AppParams,
            ) -> root::dmHID::HContext;
        }
    }
    pub mod dmDDF {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Descriptor {
            _unused: [u8; 0],
        }
        pub const OPTION_OFFSET_POINTERS: u32 = 1;
        pub const Result_RESULT_OK: root::dmDDF::Result = 0;
        pub const Result_RESULT_FIELDTYPE_MISMATCH: root::dmDDF::Result = 1;
        pub const Result_RESULT_WIRE_FORMAT_ERROR: root::dmDDF::Result = 2;
        pub const Result_RESULT_IO_ERROR: root::dmDDF::Result = 3;
        pub const Result_RESULT_VERSION_MISMATCH: root::dmDDF::Result = 4;
        pub const Result_RESULT_MISSING_REQUIRED: root::dmDDF::Result = 5;
        pub const Result_RESULT_INTERNAL_ERROR: root::dmDDF::Result = 1000;
        pub type Result = ::std::os::raw::c_uint;
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF21GetDescriptorFromHashEm"]
            pub fn GetDescriptorFromHash(hash: root::dmhash_t) -> *const root::dmDDF::Descriptor;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF11LoadMessageEPKvjPKNS_10DescriptorEPPv"]
            pub fn LoadMessage(
                buffer: *const ::std::os::raw::c_void,
                buffer_size: u32,
                desc: *const root::dmDDF::Descriptor,
                message: *mut *mut ::std::os::raw::c_void,
            ) -> root::dmDDF::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF11LoadMessageEPKvjPKNS_10DescriptorEPPvjPj"]
            pub fn LoadMessage1(
                buffer: *const ::std::os::raw::c_void,
                buffer_size: u32,
                desc: *const root::dmDDF::Descriptor,
                message: *mut *mut ::std::os::raw::c_void,
                options: u32,
                size: *mut u32,
            ) -> root::dmDDF::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF18SaveMessageToArrayEPKvPKNS_10DescriptorER7dmArrayIhE"]
            pub fn SaveMessageToArray(
                message: *const ::std::os::raw::c_void,
                desc: *const root::dmDDF::Descriptor,
                array: *mut root::dmArray<u8>,
            ) -> root::dmDDF::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF19LoadMessageFromFileEPKcPKNS_10DescriptorEPPv"]
            pub fn LoadMessageFromFile(
                file_name: *const ::std::os::raw::c_char,
                desc: *const root::dmDDF::Descriptor,
                message: *mut *mut ::std::os::raw::c_void,
            ) -> root::dmDDF::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF15ResolvePointersEPKNS_10DescriptorEPv"]
            pub fn ResolvePointers(
                desc: *const root::dmDDF::Descriptor,
                message: *mut ::std::os::raw::c_void,
            ) -> root::dmDDF::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmDDF11FreeMessageEPv"]
            pub fn FreeMessage(message: *mut ::std::os::raw::c_void);
        }
    }
    pub mod dmScript {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Context {
            _unused: [u8; 0],
        }
        pub type HContext = *mut root::dmScript::Context;
        #[doc = " LuaStackCheck struct. Internal\n\n LuaStackCheck utility to make sure we check the Lua stack state before leaving a function.\n m_Diff is the expected difference of the stack size.\n"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct LuaStackCheck {
            #[doc = " The Lua state to check"]
            pub m_L: *mut root::lua_State,
            #[doc = " Debug info in case of an assert"]
            pub m_Filename: *const ::std::os::raw::c_char,
            pub m_Linenumber: ::std::os::raw::c_int,
            #[doc = " The current top of the Lua stack (from lua_gettop())"]
            pub m_Top: ::std::os::raw::c_int,
            #[doc = " The expected difference in stack size when this sctruct goes out of scope"]
            pub m_Diff: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_LuaStackCheck() {
            const UNINIT: ::std::mem::MaybeUninit<LuaStackCheck> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<LuaStackCheck>(),
                32usize,
                concat!("Size of: ", stringify!(LuaStackCheck))
            );
            assert_eq!(
                ::std::mem::align_of::<LuaStackCheck>(),
                8usize,
                concat!("Alignment of ", stringify!(LuaStackCheck))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_L) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaStackCheck),
                    "::",
                    stringify!(m_L)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Filename) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaStackCheck),
                    "::",
                    stringify!(m_Filename)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Linenumber) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaStackCheck),
                    "::",
                    stringify!(m_Linenumber)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Top) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaStackCheck),
                    "::",
                    stringify!(m_Top)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Diff) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaStackCheck),
                    "::",
                    stringify!(m_Diff)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13LuaStackCheck6VerifyEi"]
            pub fn LuaStackCheck_Verify(
                this: *mut root::dmScript::LuaStackCheck,
                diff: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13LuaStackCheck5ErrorEPKcz"]
            pub fn LuaStackCheck_Error(
                this: *mut root::dmScript::LuaStackCheck,
                fmt: *const ::std::os::raw::c_char,
                ...
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13LuaStackCheckC1EP9lua_StateiPKci"]
            pub fn LuaStackCheck_LuaStackCheck(
                this: *mut root::dmScript::LuaStackCheck,
                L: *mut root::lua_State,
                diff: ::std::os::raw::c_int,
                filename: *const ::std::os::raw::c_char,
                linenumber: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13LuaStackCheckD1Ev"]
            pub fn LuaStackCheck_LuaStackCheck_destructor(this: *mut root::dmScript::LuaStackCheck);
        }
        impl LuaStackCheck {
            #[inline]
            pub unsafe fn Verify(&mut self, diff: ::std::os::raw::c_int) {
                LuaStackCheck_Verify(self, diff)
            }
            #[inline]
            pub unsafe fn new(
                L: *mut root::lua_State,
                diff: ::std::os::raw::c_int,
                filename: *const ::std::os::raw::c_char,
                linenumber: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LuaStackCheck_LuaStackCheck(
                    __bindgen_tmp.as_mut_ptr(),
                    L,
                    diff,
                    filename,
                    linenumber,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                LuaStackCheck_LuaStackCheck_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript3RefEP9lua_Statei"]
            pub fn Ref(
                L: *mut root::lua_State,
                table: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript5UnrefEP9lua_Stateii"]
            pub fn Unref(
                L: *mut root::lua_State,
                table: ::std::os::raw::c_int,
                reference: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11GetInstanceEP9lua_State"]
            pub fn GetInstance(L: *mut root::lua_State);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11SetInstanceEP9lua_State"]
            pub fn SetInstance(L: *mut root::lua_State);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15IsInstanceValidEP9lua_State"]
            pub fn IsInstanceValid(L: *mut root::lua_State) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13GetMainThreadEP9lua_State"]
            pub fn GetMainThread(L: *mut root::lua_State) -> *mut root::lua_State;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11GetLuaStateEPNS_7ContextE"]
            pub fn GetLuaState(context: root::dmScript::HContext) -> *mut root::lua_State;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9ToVector3EP9lua_Statei"]
            pub fn ToVector3(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Vector3;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9IsVector3EP9lua_Statei"]
            pub fn IsVector3(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11PushVector3EP9lua_StateRKN10Vectormath3Aos7Vector3E"]
            pub fn PushVector3(L: *mut root::lua_State, v: *const root::dmVMath::Vector3);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript12CheckVector3EP9lua_Statei"]
            pub fn CheckVector3(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Vector3;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9ToVector4EP9lua_Statei"]
            pub fn ToVector4(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Vector4;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9IsVector4EP9lua_Statei"]
            pub fn IsVector4(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11PushVector4EP9lua_StateRKN10Vectormath3Aos7Vector4E"]
            pub fn PushVector4(L: *mut root::lua_State, v: *const root::dmVMath::Vector4);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript12CheckVector4EP9lua_Statei"]
            pub fn CheckVector4(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Vector4;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript6ToQuatEP9lua_Statei"]
            pub fn ToQuat(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Quat;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript6IsQuatEP9lua_Statei"]
            pub fn IsQuat(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript8PushQuatEP9lua_StateRKN10Vectormath3Aos4QuatE"]
            pub fn PushQuat(L: *mut root::lua_State, q: *const root::dmVMath::Quat);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9CheckQuatEP9lua_Statei"]
            pub fn CheckQuat(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Quat;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9ToMatrix4EP9lua_Statei"]
            pub fn ToMatrix4(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Matrix4;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9IsMatrix4EP9lua_Statei"]
            pub fn IsMatrix4(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11PushMatrix4EP9lua_StateRKN10Vectormath3Aos7Matrix4E"]
            pub fn PushMatrix4(L: *mut root::lua_State, m: *const root::dmVMath::Matrix4);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript12CheckMatrix4EP9lua_Statei"]
            pub fn CheckMatrix4(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmVMath::Matrix4;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript6IsHashEP9lua_Statei"]
            pub fn IsHash(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript8PushHashEP9lua_Statem"]
            pub fn PushHash(L: *mut root::lua_State, hash: root::dmhash_t);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9CheckHashEP9lua_Statei"]
            pub fn CheckHash(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript17CheckHashOrStringEP9lua_Statei"]
            pub fn CheckHashOrString(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> root::dmhash_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript25GetStringFromHashOrStringEP9lua_StateiPcj"]
            pub fn GetStringFromHashOrString(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
                buffer: *mut ::std::os::raw::c_char,
                bufferlength: u32,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript7PushDDFEP9lua_StatePKN5dmDDF10DescriptorEPKcb"]
            pub fn PushDDF(
                L: *mut root::lua_State,
                descriptor: *const root::dmDDF::Descriptor,
                data: *const ::std::os::raw::c_char,
                pointers_are_offsets: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9JsonToLuaEP9lua_StatePKcm"]
            pub fn JsonToLua(
                L: *mut root::lua_State,
                json: *const ::std::os::raw::c_char,
                json_len: usize,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript9LuaToJsonEP9lua_StatePPcPm"]
            pub fn LuaToJson(
                L: *mut root::lua_State,
                json: *mut *mut ::std::os::raw::c_char,
                json_len: *mut usize,
            ) -> ::std::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LuaCallbackInfo {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript14CreateCallbackEP9lua_Statei"]
            pub fn CreateCallback(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmScript::LuaCallbackInfo;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15IsCallbackValidEPNS_15LuaCallbackInfoE"]
            pub fn IsCallbackValid(cbk: *mut root::dmScript::LuaCallbackInfo) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15DestroyCallbackEPNS_15LuaCallbackInfoE"]
            pub fn DestroyCallback(cbk: *mut root::dmScript::LuaCallbackInfo);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript21GetCallbackLuaContextEPNS_15LuaCallbackInfoE"]
            pub fn GetCallbackLuaContext(
                cbk: *mut root::dmScript::LuaCallbackInfo,
            ) -> *mut root::lua_State;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13SetupCallbackEPNS_15LuaCallbackInfoE"]
            pub fn SetupCallback(cbk: *mut root::dmScript::LuaCallbackInfo) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript16TeardownCallbackEPNS_15LuaCallbackInfoE"]
            pub fn TeardownCallback(cbk: *mut root::dmScript::LuaCallbackInfo);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript5PCallEP9lua_Stateii"]
            pub fn PCall(
                L: *mut root::lua_State,
                nargs: ::std::os::raw::c_int,
                nresult: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript13RefInInstanceEP9lua_State"]
            pub fn RefInInstance(L: *mut root::lua_State) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15UnrefInInstanceEP9lua_Statei"]
            pub fn UnrefInInstance(L: *mut root::lua_State, ref_: ::std::os::raw::c_int);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10ResolveURLEP9lua_StateiPN9dmMessage3URLES4_"]
            pub fn ResolveURL(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
                out_url: *mut root::dmMessage::URL,
                out_default_url: *mut root::dmMessage::URL,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10ResolveURLEP9lua_StatePKcPN9dmMessage3URLES6_"]
            pub fn ResolveURL1(
                L: *mut root::lua_State,
                url: *const ::std::os::raw::c_char,
                out_url: *mut root::dmMessage::URL,
                default_url: *mut root::dmMessage::URL,
            ) -> root::dmMessage::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11UrlToStringEPKN9dmMessage3URLEPcj"]
            pub fn UrlToString(
                url: *const root::dmMessage::URL,
                buffer: *mut ::std::os::raw::c_char,
                buffer_size: u32,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Get the size of a table when serialized\n @name CheckTableSize\n @param L [type: lua_State*] Lua state\n @param index [type: int] Index of the table\n @return result [type: uint32_t] Number of bytes required for the serialized table"]
            #[link_name = "\u{1}_ZN8dmScript14CheckTableSizeEP9lua_Statei"]
            pub fn CheckTableSize(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10CheckTableEP9lua_StatePcji"]
            pub fn CheckTable(
                L: *mut root::lua_State,
                buffer: *mut ::std::os::raw::c_char,
                buffer_size: u32,
                index: ::std::os::raw::c_int,
            ) -> u32;
        }
        extern "C" {
            #[doc = " Push a serialized table to the supplied lua state, will increase the stack by 1.\n * @name PushTable\n @param L [type: lua_State*] Lua state\n @param data [type: const char*] Buffer with serialized table to push\n @param data_size [type: uint32_t] Size of buffer of serialized data"]
            #[link_name = "\u{1}_ZN8dmScript9PushTableEP9lua_StatePKcj"]
            pub fn PushTable(
                L: *mut root::lua_State,
                data: *const ::std::os::raw::c_char,
                data_size: u32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15CheckGOInstanceEP9lua_State"]
            pub fn CheckGOInstance(L: *mut root::lua_State) -> root::dmGameObject::HInstance;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15CheckGOInstanceEP9lua_Statei"]
            pub fn CheckGOInstance1(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> root::dmGameObject::HInstance;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript15CheckCollectionEP9lua_State"]
            pub fn CheckCollection(L: *mut root::lua_State) -> root::dmGameObject::HCollection;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript19GetComponentFromLuaEP9lua_StateiPKcPPvS5_PN9dmMessage3URLE"]
            pub fn GetComponentFromLua(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
                component_type: *const ::std::os::raw::c_char,
                out_world: *mut root::dmGameObject::HComponentWorld,
                component: *mut root::dmGameObject::HComponent,
                url: *mut root::dmMessage::URL,
            );
        }
        pub const LuaBufferOwnership_OWNER_C: root::dmScript::LuaBufferOwnership = 0;
        pub const LuaBufferOwnership_OWNER_LUA: root::dmScript::LuaBufferOwnership = 1;
        pub const LuaBufferOwnership_OWNER_RES: root::dmScript::LuaBufferOwnership = 2;
        pub type LuaBufferOwnership = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct LuaHBuffer {
            pub __bindgen_anon_1: root::dmScript::LuaHBuffer__bindgen_ty_1,
            pub __bindgen_anon_2: root::dmScript::LuaHBuffer__bindgen_ty_2,
            pub m_BufferResPathHash: root::dmhash_t,
            pub m_BufferResVersion: u16,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union LuaHBuffer__bindgen_ty_1 {
            pub m_Buffer: root::dmBuffer::HBuffer,
            pub m_BufferRes: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_LuaHBuffer__bindgen_ty_1() {
            const UNINIT: ::std::mem::MaybeUninit<LuaHBuffer__bindgen_ty_1> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<LuaHBuffer__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(LuaHBuffer__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<LuaHBuffer__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(LuaHBuffer__bindgen_ty_1))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Buffer) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaHBuffer__bindgen_ty_1),
                    "::",
                    stringify!(m_Buffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_BufferRes) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaHBuffer__bindgen_ty_1),
                    "::",
                    stringify!(m_BufferRes)
                )
            );
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union LuaHBuffer__bindgen_ty_2 {
            pub m_UseLuaGC: bool,
            pub m_Owner: root::dmScript::LuaBufferOwnership,
        }
        #[test]
        fn bindgen_test_layout_LuaHBuffer__bindgen_ty_2() {
            const UNINIT: ::std::mem::MaybeUninit<LuaHBuffer__bindgen_ty_2> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<LuaHBuffer__bindgen_ty_2>(),
                4usize,
                concat!("Size of: ", stringify!(LuaHBuffer__bindgen_ty_2))
            );
            assert_eq!(
                ::std::mem::align_of::<LuaHBuffer__bindgen_ty_2>(),
                4usize,
                concat!("Alignment of ", stringify!(LuaHBuffer__bindgen_ty_2))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_UseLuaGC) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaHBuffer__bindgen_ty_2),
                    "::",
                    stringify!(m_UseLuaGC)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Owner) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaHBuffer__bindgen_ty_2),
                    "::",
                    stringify!(m_Owner)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_LuaHBuffer() {
            const UNINIT: ::std::mem::MaybeUninit<LuaHBuffer> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<LuaHBuffer>(),
                32usize,
                concat!("Size of: ", stringify!(LuaHBuffer))
            );
            assert_eq!(
                ::std::mem::align_of::<LuaHBuffer>(),
                8usize,
                concat!("Alignment of ", stringify!(LuaHBuffer))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_BufferResPathHash) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaHBuffer),
                    "::",
                    stringify!(m_BufferResPathHash)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_BufferResVersion) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LuaHBuffer),
                    "::",
                    stringify!(m_BufferResVersion)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10LuaHBufferC1Ev"]
            pub fn LuaHBuffer_LuaHBuffer(this: *mut root::dmScript::LuaHBuffer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10LuaHBufferC1EjNS_18LuaBufferOwnershipE"]
            pub fn LuaHBuffer_LuaHBuffer1(
                this: *mut root::dmScript::LuaHBuffer,
                buffer: root::dmBuffer::HBuffer,
                ownership: root::dmScript::LuaBufferOwnership,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10LuaHBufferC1EP15ResourceFactoryPv"]
            pub fn LuaHBuffer_LuaHBuffer2(
                this: *mut root::dmScript::LuaHBuffer,
                factory: root::dmResource::HFactory,
                buffer_resource: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10LuaHBufferC1Ejb"]
            pub fn LuaHBuffer_LuaHBuffer3(
                this: *mut root::dmScript::LuaHBuffer,
                buffer: root::dmBuffer::HBuffer,
                use_lua_gc: bool,
            );
        }
        impl LuaHBuffer {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LuaHBuffer_LuaHBuffer(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                buffer: root::dmBuffer::HBuffer,
                ownership: root::dmScript::LuaBufferOwnership,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LuaHBuffer_LuaHBuffer1(__bindgen_tmp.as_mut_ptr(), buffer, ownership);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                factory: root::dmResource::HFactory,
                buffer_resource: *mut ::std::os::raw::c_void,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LuaHBuffer_LuaHBuffer2(__bindgen_tmp.as_mut_ptr(), factory, buffer_resource);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(buffer: root::dmBuffer::HBuffer, use_lua_gc: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LuaHBuffer_LuaHBuffer3(__bindgen_tmp.as_mut_ptr(), buffer, use_lua_gc);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript8IsBufferEP9lua_Statei"]
            pub fn IsBuffer(L: *mut root::lua_State, index: ::std::os::raw::c_int) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript10PushBufferEP9lua_StateRKNS_10LuaHBufferE"]
            pub fn PushBuffer(L: *mut root::lua_State, buffer: *const root::dmScript::LuaHBuffer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript11CheckBufferEP9lua_Statei"]
            pub fn CheckBuffer(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmScript::LuaHBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript18CheckBufferNoErrorEP9lua_Statei"]
            pub fn CheckBufferNoError(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> *mut root::dmScript::LuaHBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript17CheckBufferUnpackEP9lua_Statei"]
            pub fn CheckBufferUnpack(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> root::dmBuffer::HBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmScript24CheckBufferUnpackNoErrorEP9lua_Statei"]
            pub fn CheckBufferUnpackNoError(
                L: *mut root::lua_State,
                index: ::std::os::raw::c_int,
            ) -> root::dmBuffer::HBuffer;
        }
    }
    pub mod dmBuffer {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type HBuffer = u32;
        pub const ValueType_VALUE_TYPE_UINT8: root::dmBuffer::ValueType = 0;
        pub const ValueType_VALUE_TYPE_UINT16: root::dmBuffer::ValueType = 1;
        pub const ValueType_VALUE_TYPE_UINT32: root::dmBuffer::ValueType = 2;
        pub const ValueType_VALUE_TYPE_UINT64: root::dmBuffer::ValueType = 3;
        pub const ValueType_VALUE_TYPE_INT8: root::dmBuffer::ValueType = 4;
        pub const ValueType_VALUE_TYPE_INT16: root::dmBuffer::ValueType = 5;
        pub const ValueType_VALUE_TYPE_INT32: root::dmBuffer::ValueType = 6;
        pub const ValueType_VALUE_TYPE_INT64: root::dmBuffer::ValueType = 7;
        pub const ValueType_VALUE_TYPE_FLOAT32: root::dmBuffer::ValueType = 8;
        pub const ValueType_MAX_VALUE_TYPE_COUNT: root::dmBuffer::ValueType = 9;
        pub type ValueType = ::std::os::raw::c_uint;
        pub const Result_RESULT_OK: root::dmBuffer::Result = 0;
        pub const Result_RESULT_GUARD_INVALID: root::dmBuffer::Result = 1;
        pub const Result_RESULT_ALLOCATION_ERROR: root::dmBuffer::Result = 2;
        pub const Result_RESULT_BUFFER_INVALID: root::dmBuffer::Result = 3;
        pub const Result_RESULT_BUFFER_SIZE_ERROR: root::dmBuffer::Result = 4;
        pub const Result_RESULT_STREAM_SIZE_ERROR: root::dmBuffer::Result = 5;
        pub const Result_RESULT_STREAM_MISSING: root::dmBuffer::Result = 6;
        pub const Result_RESULT_STREAM_TYPE_MISMATCH: root::dmBuffer::Result = 7;
        pub const Result_RESULT_STREAM_COUNT_MISMATCH: root::dmBuffer::Result = 8;
        pub const Result_RESULT_STREAM_MISMATCH: root::dmBuffer::Result = 9;
        pub const Result_RESULT_METADATA_INVALID: root::dmBuffer::Result = 10;
        pub const Result_RESULT_METADATA_MISSING: root::dmBuffer::Result = 11;
        pub type Result = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StreamDeclaration {
            pub m_Name: root::dmhash_t,
            pub m_Type: root::dmBuffer::ValueType,
            pub m_Count: u8,
            pub m_Flags: u32,
            pub m_Reserved: u32,
        }
        #[test]
        fn bindgen_test_layout_StreamDeclaration() {
            const UNINIT: ::std::mem::MaybeUninit<StreamDeclaration> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<StreamDeclaration>(),
                24usize,
                concat!("Size of: ", stringify!(StreamDeclaration))
            );
            assert_eq!(
                ::std::mem::align_of::<StreamDeclaration>(),
                8usize,
                concat!("Alignment of ", stringify!(StreamDeclaration))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Name) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StreamDeclaration),
                    "::",
                    stringify!(m_Name)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Type) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StreamDeclaration),
                    "::",
                    stringify!(m_Type)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Count) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StreamDeclaration),
                    "::",
                    stringify!(m_Count)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Flags) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StreamDeclaration),
                    "::",
                    stringify!(m_Flags)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Reserved) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StreamDeclaration),
                    "::",
                    stringify!(m_Reserved)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer6CreateEjPKNS_17StreamDeclarationEhPj"]
            pub fn Create(
                count: u32,
                streams_decl: *const root::dmBuffer::StreamDeclaration,
                streams_decl_count: u8,
                out_buffer: *mut root::dmBuffer::HBuffer,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer4CopyEjj"]
            pub fn Copy(
                dst_buffer_handle: root::dmBuffer::HBuffer,
                src_buffer_handle: root::dmBuffer::HBuffer,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer7DestroyEj"]
            pub fn Destroy(buffer: root::dmBuffer::HBuffer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer13IsBufferValidEj"]
            pub fn IsBufferValid(buffer: root::dmBuffer::HBuffer) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer14ValidateBufferEj"]
            pub fn ValidateBuffer(buffer: root::dmBuffer::HBuffer) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer9GetStreamEjmPPvPjS2_S2_"]
            pub fn GetStream(
                buffer: root::dmBuffer::HBuffer,
                stream_name: root::dmhash_t,
                stream: *mut *mut ::std::os::raw::c_void,
                count: *mut u32,
                components: *mut u32,
                stride: *mut u32,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer8GetBytesEjPPvPj"]
            pub fn GetBytes(
                buffer: root::dmBuffer::HBuffer,
                out_bytes: *mut *mut ::std::os::raw::c_void,
                out_size: *mut u32,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer8GetCountEjPj"]
            pub fn GetCount(
                buffer: root::dmBuffer::HBuffer,
                count: *mut u32,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer13GetStreamTypeEjmPNS_9ValueTypeEPj"]
            pub fn GetStreamType(
                buffer: root::dmBuffer::HBuffer,
                stream_name: root::dmhash_t,
                type_: *mut root::dmBuffer::ValueType,
                components: *mut u32,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer19GetSizeForValueTypeENS_9ValueTypeE"]
            pub fn GetSizeForValueType(type_: root::dmBuffer::ValueType) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer15GetResultStringENS_6ResultE"]
            pub fn GetResultString(result: root::dmBuffer::Result)
                -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer18GetValueTypeStringENS_9ValueTypeE"]
            pub fn GetValueTypeString(
                value: root::dmBuffer::ValueType,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer17GetContentVersionEjPj"]
            pub fn GetContentVersion(
                hbuffer: root::dmBuffer::HBuffer,
                version: *mut u32,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer20UpdateContentVersionEj"]
            pub fn UpdateContentVersion(hbuffer: root::dmBuffer::HBuffer)
                -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer11SetMetaDataEjmPKvjNS_9ValueTypeE"]
            pub fn SetMetaData(
                hbuffer: root::dmBuffer::HBuffer,
                name_hash: root::dmhash_t,
                data: *const ::std::os::raw::c_void,
                count: u32,
                type_: root::dmBuffer::ValueType,
            ) -> root::dmBuffer::Result;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN8dmBuffer11GetMetaDataEjmPPvPjPNS_9ValueTypeE"]
            pub fn GetMetaData(
                hbuffer: root::dmBuffer::HBuffer,
                name_hash: root::dmhash_t,
                data: *mut *mut ::std::os::raw::c_void,
                count: *mut u32,
                type_: *mut root::dmBuffer::ValueType,
            ) -> root::dmBuffer::Result;
        }
    }
    #[doc = "!< LOG_SEVERITY_DEBUG"]
    pub const LogSeverity_LOG_SEVERITY_DEBUG: root::LogSeverity = 0;
    #[doc = "!< LOG_SEVERITY_USER_DEBUG"]
    pub const LogSeverity_LOG_SEVERITY_USER_DEBUG: root::LogSeverity = 1;
    #[doc = "!< LOG_SEVERITY_INFO"]
    pub const LogSeverity_LOG_SEVERITY_INFO: root::LogSeverity = 2;
    #[doc = "!< LOG_SEVERITY_WARNING"]
    pub const LogSeverity_LOG_SEVERITY_WARNING: root::LogSeverity = 3;
    #[doc = "!< LOG_SEVERITY_ERROR"]
    pub const LogSeverity_LOG_SEVERITY_ERROR: root::LogSeverity = 4;
    #[doc = "!< LOG_SEVERITY_FATAL"]
    pub const LogSeverity_LOG_SEVERITY_FATAL: root::LogSeverity = 5;
    pub type LogSeverity = ::std::os::raw::c_uint;
    extern "C" {
        pub fn LogInternal(
            severity: root::LogSeverity,
            domain: *const ::std::os::raw::c_char,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    pub type FLogListener = ::std::option::Option<
        unsafe extern "C" fn(
            severity: root::LogSeverity,
            domain: *const ::std::os::raw::c_char,
            formatted_string: *const ::std::os::raw::c_char,
        ),
    >;
    extern "C" {
        pub fn dmLogRegisterListener(listener: root::FLogListener);
    }
    extern "C" {
        pub fn dmLogUnregisterListener(listener: root::FLogListener);
    }
    extern "C" {
        pub fn dmLogSetLevel(severity: root::LogSeverity);
    }
    extern "C" {
        pub fn dmLogGetLevel() -> root::LogSeverity;
    }
    pub mod dmLog {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN5dmLog19RegisterLogListenerEPFv11LogSeverityPKcS2_E"]
            pub fn RegisterLogListener(listener: root::FLogListener);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmLog21UnregisterLogListenerEPFv11LogSeverityPKcS2_E"]
            pub fn UnregisterLogListener(listener: root::FLogListener);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN5dmLog8SetlevelE11LogSeverity"]
            pub fn Setlevel(severity: root::LogSeverity);
        }
    }
    pub mod dmTime {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN6dmTime7GetTimeEv"]
            pub fn GetTime() -> u64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN6dmTime5SleepEj"]
            pub fn Sleep(useconds: u32);
        }
    }
    pub mod dmMutex {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Mutex {
            _unused: [u8; 0],
        }
        pub type HMutex = *mut root::dmMutex::Mutex;
        extern "C" {
            #[link_name = "\u{1}_ZN7dmMutex3NewEv"]
            pub fn New() -> root::dmMutex::HMutex;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7dmMutex6DeleteEPNS_5MutexE"]
            pub fn Delete(mutex: root::dmMutex::HMutex);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7dmMutex4LockEPNS_5MutexE"]
            pub fn Lock(mutex: root::dmMutex::HMutex);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7dmMutex7TryLockEPNS_5MutexE"]
            pub fn TryLock(mutex: root::dmMutex::HMutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN7dmMutex6UnlockEPNS_5MutexE"]
            pub fn Unlock(mutex: root::dmMutex::HMutex);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ScopedLock {
            pub m_Mutex: root::dmMutex::HMutex,
        }
        #[test]
        fn bindgen_test_layout_ScopedLock() {
            const UNINIT: ::std::mem::MaybeUninit<ScopedLock> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ScopedLock>(),
                8usize,
                concat!("Size of: ", stringify!(ScopedLock))
            );
            assert_eq!(
                ::std::mem::align_of::<ScopedLock>(),
                8usize,
                concat!("Alignment of ", stringify!(ScopedLock))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).m_Mutex) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScopedLock),
                    "::",
                    stringify!(m_Mutex)
                )
            );
        }
    }
    pub mod dmConditionVariable {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConditionVariable {
            _unused: [u8; 0],
        }
        pub type HConditionVariable = *mut root::dmConditionVariable::ConditionVariable;
        extern "C" {
            #[link_name = "\u{1}_ZN19dmConditionVariable3NewEv"]
            pub fn New() -> root::dmConditionVariable::HConditionVariable;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN19dmConditionVariable6DeleteEPNS_17ConditionVariableE"]
            pub fn Delete(condition: root::dmConditionVariable::HConditionVariable);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN19dmConditionVariable4WaitEPNS_17ConditionVariableEPN7dmMutex5MutexE"]
            pub fn Wait(
                condition: root::dmConditionVariable::HConditionVariable,
                mutex: root::dmMutex::HMutex,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN19dmConditionVariable6SignalEPNS_17ConditionVariableE"]
            pub fn Signal(condition: root::dmConditionVariable::HConditionVariable);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN19dmConditionVariable9BroadcastEPNS_17ConditionVariableE"]
            pub fn Broadcast(condition: root::dmConditionVariable::HConditionVariable);
        }
    }
    extern "C" {
        #[link_name = "\u{1}_Z10dmSnPrintfPcmPKcz"]
        pub fn dmSnPrintf(
            buffer: *mut ::std::os::raw::c_char,
            count: usize,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_Z8dmStrTokPcPKcPS_"]
        pub fn dmStrTok(
            string: *mut ::std::os::raw::c_char,
            delim: *const ::std::os::raw::c_char,
            lasts: *mut *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z9dmStrlCpyPcPKcm"]
        pub fn dmStrlCpy(
            dst: *mut ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            size: usize,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z9dmStrlCatPcPKcm"]
        pub fn dmStrlCat(
            dst: *mut ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            size: usize,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12dmStrCaseCmpPKcS0_"]
        pub fn dmStrCaseCmp(
            s1: *const ::std::os::raw::c_char,
            s2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_Z10dmStrErrorPcmi"]
        pub fn dmStrError(
            dst: *mut ::std::os::raw::c_char,
            size: usize,
            err: ::std::os::raw::c_int,
        );
    }
    pub type id = *mut ::std::os::raw::c_void;
    pub type EGLContext = *mut ::std::os::raw::c_void;
    pub type EGLSurface = *mut ::std::os::raw::c_void;
    pub type JavaVM = *mut ::std::os::raw::c_void;
    pub type jobject = *mut ::std::os::raw::c_void;
    pub type android_app = *mut ::std::os::raw::c_void;
    pub type HWND = *mut ::std::os::raw::c_void;
    pub type HGLRC = *mut ::std::os::raw::c_void;
    pub type XID = ::std::os::raw::c_ulong;
    pub type Window = root::XID;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __GLXcontextRec {
        _unused: [u8; 0],
    }
    pub type GLXContext = *mut root::__GLXcontextRec;
    pub mod dmGraphics {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics20GetNativeiOSUIWindowEv"]
            pub fn GetNativeiOSUIWindow() -> root::id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics18GetNativeiOSUIViewEv"]
            pub fn GetNativeiOSUIView() -> root::id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics23GetNativeiOSEAGLContextEv"]
            pub fn GetNativeiOSEAGLContext() -> root::id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics20GetNativeOSXNSWindowEv"]
            pub fn GetNativeOSXNSWindow() -> root::id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics18GetNativeOSXNSViewEv"]
            pub fn GetNativeOSXNSView() -> root::id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics27GetNativeOSXNSOpenGLContextEv"]
            pub fn GetNativeOSXNSOpenGLContext() -> root::id;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics20GetNativeWindowsHWNDEv"]
            pub fn GetNativeWindowsHWND() -> root::HWND;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics21GetNativeWindowsHGLRCEv"]
            pub fn GetNativeWindowsHGLRC() -> root::HGLRC;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics26GetNativeAndroidEGLContextEv"]
            pub fn GetNativeAndroidEGLContext() -> root::EGLContext;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics26GetNativeAndroidEGLSurfaceEv"]
            pub fn GetNativeAndroidEGLSurface() -> root::EGLSurface;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics22GetNativeAndroidJavaVMEv"]
            pub fn GetNativeAndroidJavaVM() -> *mut root::JavaVM;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics24GetNativeAndroidActivityEv"]
            pub fn GetNativeAndroidActivity() -> root::jobject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics19GetNativeAndroidAppEv"]
            pub fn GetNativeAndroidApp() -> *mut root::android_app;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics18GetNativeX11WindowEv"]
            pub fn GetNativeX11Window() -> root::Window;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics22GetNativeX11GLXContextEv"]
            pub fn GetNativeX11GLXContext() -> root::GLXContext;
        }
        pub type HContext = *mut ::std::os::raw::c_void;
        pub type HTexture = u64;
        pub type HRenderTarget = u64;
        pub type HVertexProgram = usize;
        pub type HFragmentProgram = usize;
        pub type HProgram = usize;
        pub type HVertexBuffer = usize;
        pub type HIndexBuffer = usize;
        pub type HStorageBuffer = usize;
        pub type HUniformLocation = i64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct VertexDeclaration {
            _unused: [u8; 0],
        }
        pub type HVertexDeclaration = *mut root::dmGraphics::VertexDeclaration;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct VertexStreamDeclaration {
            _unused: [u8; 0],
        }
        pub type HVertexStreamDeclaration = *mut root::dmGraphics::VertexStreamDeclaration;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PipelineState {
            _unused: [u8; 0],
        }
        pub type HPipelineState = *mut root::dmGraphics::PipelineState;
        pub const INVALID_STREAM_OFFSET: u32 = 4294967295;
        pub const MAX_BUFFER_COLOR_ATTACHMENTS: u8 = 4;
        pub const HandleResult_HANDLE_RESULT_OK: root::dmGraphics::HandleResult = 0;
        pub const HandleResult_HANDLE_RESULT_NOT_AVAILABLE: root::dmGraphics::HandleResult = -1;
        pub const HandleResult_HANDLE_RESULT_ERROR: root::dmGraphics::HandleResult = -2;
        pub type HandleResult = ::std::os::raw::c_int;
        pub const RenderTargetAttachment_ATTACHMENT_COLOR:
            root::dmGraphics::RenderTargetAttachment = 0;
        pub const RenderTargetAttachment_ATTACHMENT_DEPTH:
            root::dmGraphics::RenderTargetAttachment = 1;
        pub const RenderTargetAttachment_ATTACHMENT_STENCIL:
            root::dmGraphics::RenderTargetAttachment = 2;
        pub const RenderTargetAttachment_MAX_ATTACHMENT_COUNT:
            root::dmGraphics::RenderTargetAttachment = 3;
        pub type RenderTargetAttachment = ::std::os::raw::c_uint;
        pub const AttachmentOp_ATTACHMENT_OP_DONT_CARE: root::dmGraphics::AttachmentOp = 0;
        pub const AttachmentOp_ATTACHMENT_OP_LOAD: root::dmGraphics::AttachmentOp = 1;
        pub const AttachmentOp_ATTACHMENT_OP_STORE: root::dmGraphics::AttachmentOp = 2;
        pub const AttachmentOp_ATTACHMENT_OP_CLEAR: root::dmGraphics::AttachmentOp = 3;
        pub type AttachmentOp = ::std::os::raw::c_uint;
        pub const TextureFormat_TEXTURE_FORMAT_LUMINANCE: root::dmGraphics::TextureFormat = 0;
        pub const TextureFormat_TEXTURE_FORMAT_LUMINANCE_ALPHA: root::dmGraphics::TextureFormat = 1;
        pub const TextureFormat_TEXTURE_FORMAT_RGB: root::dmGraphics::TextureFormat = 2;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA: root::dmGraphics::TextureFormat = 3;
        pub const TextureFormat_TEXTURE_FORMAT_RGB_16BPP: root::dmGraphics::TextureFormat = 4;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_16BPP: root::dmGraphics::TextureFormat = 5;
        pub const TextureFormat_TEXTURE_FORMAT_DEPTH: root::dmGraphics::TextureFormat = 6;
        pub const TextureFormat_TEXTURE_FORMAT_STENCIL: root::dmGraphics::TextureFormat = 7;
        pub const TextureFormat_TEXTURE_FORMAT_RGB_PVRTC_2BPPV1: root::dmGraphics::TextureFormat =
            8;
        pub const TextureFormat_TEXTURE_FORMAT_RGB_PVRTC_4BPPV1: root::dmGraphics::TextureFormat =
            9;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_PVRTC_2BPPV1: root::dmGraphics::TextureFormat =
            10;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_PVRTC_4BPPV1: root::dmGraphics::TextureFormat =
            11;
        pub const TextureFormat_TEXTURE_FORMAT_RGB_ETC1: root::dmGraphics::TextureFormat = 12;
        pub const TextureFormat_TEXTURE_FORMAT_R_ETC2: root::dmGraphics::TextureFormat = 13;
        pub const TextureFormat_TEXTURE_FORMAT_RG_ETC2: root::dmGraphics::TextureFormat = 14;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_ETC2: root::dmGraphics::TextureFormat = 15;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_ASTC_4x4: root::dmGraphics::TextureFormat = 16;
        pub const TextureFormat_TEXTURE_FORMAT_RGB_BC1: root::dmGraphics::TextureFormat = 17;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_BC3: root::dmGraphics::TextureFormat = 18;
        pub const TextureFormat_TEXTURE_FORMAT_R_BC4: root::dmGraphics::TextureFormat = 19;
        pub const TextureFormat_TEXTURE_FORMAT_RG_BC5: root::dmGraphics::TextureFormat = 20;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA_BC7: root::dmGraphics::TextureFormat = 21;
        pub const TextureFormat_TEXTURE_FORMAT_RGB16F: root::dmGraphics::TextureFormat = 22;
        pub const TextureFormat_TEXTURE_FORMAT_RGB32F: root::dmGraphics::TextureFormat = 23;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA16F: root::dmGraphics::TextureFormat = 24;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA32F: root::dmGraphics::TextureFormat = 25;
        pub const TextureFormat_TEXTURE_FORMAT_R16F: root::dmGraphics::TextureFormat = 26;
        pub const TextureFormat_TEXTURE_FORMAT_RG16F: root::dmGraphics::TextureFormat = 27;
        pub const TextureFormat_TEXTURE_FORMAT_R32F: root::dmGraphics::TextureFormat = 28;
        pub const TextureFormat_TEXTURE_FORMAT_RG32F: root::dmGraphics::TextureFormat = 29;
        pub const TextureFormat_TEXTURE_FORMAT_RGBA32UI: root::dmGraphics::TextureFormat = 30;
        pub const TextureFormat_TEXTURE_FORMAT_BGRA8U: root::dmGraphics::TextureFormat = 31;
        pub const TextureFormat_TEXTURE_FORMAT_R32UI: root::dmGraphics::TextureFormat = 32;
        pub const TextureFormat_TEXTURE_FORMAT_COUNT: root::dmGraphics::TextureFormat = 33;
        pub type TextureFormat = ::std::os::raw::c_uint;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics25GetRenderTargetAttachmentEmNS_22RenderTargetAttachmentE"]
            pub fn GetRenderTargetAttachment(
                render_target: root::dmGraphics::HRenderTarget,
                attachment_type: root::dmGraphics::RenderTargetAttachment,
            ) -> root::dmGraphics::HTexture;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics16GetTextureHandleEmPPv"]
            pub fn GetTextureHandle(
                texture: root::dmGraphics::HTexture,
                out_handle: *mut *mut ::std::os::raw::c_void,
            ) -> root::dmGraphics::HandleResult;
        }
        pub const CompareFunc_COMPARE_FUNC_NEVER: root::dmGraphics::CompareFunc = 0;
        pub const CompareFunc_COMPARE_FUNC_LESS: root::dmGraphics::CompareFunc = 1;
        pub const CompareFunc_COMPARE_FUNC_LEQUAL: root::dmGraphics::CompareFunc = 2;
        pub const CompareFunc_COMPARE_FUNC_GREATER: root::dmGraphics::CompareFunc = 3;
        pub const CompareFunc_COMPARE_FUNC_GEQUAL: root::dmGraphics::CompareFunc = 4;
        pub const CompareFunc_COMPARE_FUNC_EQUAL: root::dmGraphics::CompareFunc = 5;
        pub const CompareFunc_COMPARE_FUNC_NOTEQUAL: root::dmGraphics::CompareFunc = 6;
        pub const CompareFunc_COMPARE_FUNC_ALWAYS: root::dmGraphics::CompareFunc = 7;
        pub type CompareFunc = ::std::os::raw::c_uint;
        pub const FaceWinding_FACE_WINDING_CCW: root::dmGraphics::FaceWinding = 0;
        pub const FaceWinding_FACE_WINDING_CW: root::dmGraphics::FaceWinding = 1;
        pub type FaceWinding = ::std::os::raw::c_uint;
        pub const StencilOp_STENCIL_OP_KEEP: root::dmGraphics::StencilOp = 0;
        pub const StencilOp_STENCIL_OP_ZERO: root::dmGraphics::StencilOp = 1;
        pub const StencilOp_STENCIL_OP_REPLACE: root::dmGraphics::StencilOp = 2;
        pub const StencilOp_STENCIL_OP_INCR: root::dmGraphics::StencilOp = 3;
        pub const StencilOp_STENCIL_OP_INCR_WRAP: root::dmGraphics::StencilOp = 4;
        pub const StencilOp_STENCIL_OP_DECR: root::dmGraphics::StencilOp = 5;
        pub const StencilOp_STENCIL_OP_DECR_WRAP: root::dmGraphics::StencilOp = 6;
        pub const StencilOp_STENCIL_OP_INVERT: root::dmGraphics::StencilOp = 7;
        pub type StencilOp = ::std::os::raw::c_uint;
        pub const BufferUsage_BUFFER_USAGE_STREAM_DRAW: root::dmGraphics::BufferUsage = 0;
        pub const BufferUsage_BUFFER_USAGE_DYNAMIC_DRAW: root::dmGraphics::BufferUsage = 1;
        pub const BufferUsage_BUFFER_USAGE_STATIC_DRAW: root::dmGraphics::BufferUsage = 2;
        pub const BufferUsage_BUFFER_USAGE_TRANSFER: root::dmGraphics::BufferUsage = 4;
        pub type BufferUsage = ::std::os::raw::c_uint;
        pub const BufferAccess_BUFFER_ACCESS_READ_ONLY: root::dmGraphics::BufferAccess = 0;
        pub const BufferAccess_BUFFER_ACCESS_WRITE_ONLY: root::dmGraphics::BufferAccess = 1;
        pub const BufferAccess_BUFFER_ACCESS_READ_WRITE: root::dmGraphics::BufferAccess = 2;
        pub type BufferAccess = ::std::os::raw::c_uint;
        pub const IndexBufferFormat_INDEXBUFFER_FORMAT_16: root::dmGraphics::IndexBufferFormat = 0;
        pub const IndexBufferFormat_INDEXBUFFER_FORMAT_32: root::dmGraphics::IndexBufferFormat = 1;
        pub type IndexBufferFormat = ::std::os::raw::c_uint;
        pub const PrimitiveType_PRIMITIVE_LINES: root::dmGraphics::PrimitiveType = 0;
        pub const PrimitiveType_PRIMITIVE_TRIANGLES: root::dmGraphics::PrimitiveType = 1;
        pub const PrimitiveType_PRIMITIVE_TRIANGLE_STRIP: root::dmGraphics::PrimitiveType = 2;
        pub type PrimitiveType = ::std::os::raw::c_uint;
        pub const Type_TYPE_BYTE: root::dmGraphics::Type = 0;
        pub const Type_TYPE_UNSIGNED_BYTE: root::dmGraphics::Type = 1;
        pub const Type_TYPE_SHORT: root::dmGraphics::Type = 2;
        pub const Type_TYPE_UNSIGNED_SHORT: root::dmGraphics::Type = 3;
        pub const Type_TYPE_INT: root::dmGraphics::Type = 4;
        pub const Type_TYPE_UNSIGNED_INT: root::dmGraphics::Type = 5;
        pub const Type_TYPE_FLOAT: root::dmGraphics::Type = 6;
        pub const Type_TYPE_FLOAT_VEC4: root::dmGraphics::Type = 7;
        pub const Type_TYPE_FLOAT_MAT4: root::dmGraphics::Type = 8;
        pub const Type_TYPE_SAMPLER_2D: root::dmGraphics::Type = 9;
        pub const Type_TYPE_SAMPLER_CUBE: root::dmGraphics::Type = 10;
        pub const Type_TYPE_SAMPLER_2D_ARRAY: root::dmGraphics::Type = 11;
        pub const Type_TYPE_FLOAT_VEC2: root::dmGraphics::Type = 12;
        pub const Type_TYPE_FLOAT_VEC3: root::dmGraphics::Type = 13;
        pub const Type_TYPE_FLOAT_MAT2: root::dmGraphics::Type = 14;
        pub const Type_TYPE_FLOAT_MAT3: root::dmGraphics::Type = 15;
        pub const Type_TYPE_IMAGE_2D: root::dmGraphics::Type = 16;
        pub type Type = ::std::os::raw::c_uint;
        pub const BlendFactor_BLEND_FACTOR_ZERO: root::dmGraphics::BlendFactor = 0;
        pub const BlendFactor_BLEND_FACTOR_ONE: root::dmGraphics::BlendFactor = 1;
        pub const BlendFactor_BLEND_FACTOR_SRC_COLOR: root::dmGraphics::BlendFactor = 2;
        pub const BlendFactor_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: root::dmGraphics::BlendFactor = 3;
        pub const BlendFactor_BLEND_FACTOR_DST_COLOR: root::dmGraphics::BlendFactor = 4;
        pub const BlendFactor_BLEND_FACTOR_ONE_MINUS_DST_COLOR: root::dmGraphics::BlendFactor = 5;
        pub const BlendFactor_BLEND_FACTOR_SRC_ALPHA: root::dmGraphics::BlendFactor = 6;
        pub const BlendFactor_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: root::dmGraphics::BlendFactor = 7;
        pub const BlendFactor_BLEND_FACTOR_DST_ALPHA: root::dmGraphics::BlendFactor = 8;
        pub const BlendFactor_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: root::dmGraphics::BlendFactor = 9;
        pub const BlendFactor_BLEND_FACTOR_SRC_ALPHA_SATURATE: root::dmGraphics::BlendFactor = 10;
        pub const BlendFactor_BLEND_FACTOR_CONSTANT_COLOR: root::dmGraphics::BlendFactor = 11;
        pub const BlendFactor_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: root::dmGraphics::BlendFactor =
            12;
        pub const BlendFactor_BLEND_FACTOR_CONSTANT_ALPHA: root::dmGraphics::BlendFactor = 13;
        pub const BlendFactor_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: root::dmGraphics::BlendFactor =
            14;
        pub type BlendFactor = ::std::os::raw::c_uint;
        pub const VertexStepFunction_VERTEX_STEP_FUNCTION_VERTEX:
            root::dmGraphics::VertexStepFunction = 0;
        pub const VertexStepFunction_VERTEX_STEP_FUNCTION_INSTANCE:
            root::dmGraphics::VertexStepFunction = 1;
        pub type VertexStepFunction = ::std::os::raw::c_uint;
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics26NewVertexStreamDeclarationEPv"]
            pub fn NewVertexStreamDeclaration(
                context: root::dmGraphics::HContext,
            ) -> root::dmGraphics::HVertexStreamDeclaration;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics15AddVertexStreamEPNS_23VertexStreamDeclarationEPKcjNS_4TypeEb"]
            pub fn AddVertexStream(
                stream_declaration: root::dmGraphics::HVertexStreamDeclaration,
                name: *const ::std::os::raw::c_char,
                size: u32,
                type_: root::dmGraphics::Type,
                normalize: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics15AddVertexStreamEPNS_23VertexStreamDeclarationEmjNS_4TypeEb"]
            pub fn AddVertexStream1(
                stream_declaration: root::dmGraphics::HVertexStreamDeclaration,
                name_hash: u64,
                size: u32,
                type_: root::dmGraphics::Type,
                normalize: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics29DeleteVertexStreamDeclarationEPNS_23VertexStreamDeclarationE"]
            pub fn DeleteVertexStreamDeclaration(
                stream_declaration: root::dmGraphics::HVertexStreamDeclaration,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics20NewVertexDeclarationEPvPNS_23VertexStreamDeclarationE"]
            pub fn NewVertexDeclaration(
                context: root::dmGraphics::HContext,
                stream_declaration: root::dmGraphics::HVertexStreamDeclaration,
            ) -> root::dmGraphics::HVertexDeclaration;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics20NewVertexDeclarationEPvPNS_23VertexStreamDeclarationEj"]
            pub fn NewVertexDeclaration1(
                context: root::dmGraphics::HContext,
                stream_declaration: root::dmGraphics::HVertexStreamDeclaration,
                stride: u32,
            ) -> root::dmGraphics::HVertexDeclaration;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics23DeleteVertexDeclarationEPNS_17VertexDeclarationE"]
            pub fn DeleteVertexDeclaration(
                vertex_declaration: root::dmGraphics::HVertexDeclaration,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics21GetVertexStreamOffsetEPNS_17VertexDeclarationEm"]
            pub fn GetVertexStreamOffset(
                vertex_declaration: root::dmGraphics::HVertexDeclaration,
                name_hash: u64,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics15NewVertexBufferEPvjPKvNS_11BufferUsageE"]
            pub fn NewVertexBuffer(
                context: root::dmGraphics::HContext,
                size: u32,
                data: *const ::std::os::raw::c_void,
                buffer_usage: root::dmGraphics::BufferUsage,
            ) -> root::dmGraphics::HVertexBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics18DeleteVertexBufferEm"]
            pub fn DeleteVertexBuffer(buffer: root::dmGraphics::HVertexBuffer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics19SetVertexBufferDataEmjPKvNS_11BufferUsageE"]
            pub fn SetVertexBufferData(
                buffer: root::dmGraphics::HVertexBuffer,
                size: u32,
                data: *const ::std::os::raw::c_void,
                buffer_usage: root::dmGraphics::BufferUsage,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics22SetVertexBufferSubDataEmjjPKv"]
            pub fn SetVertexBufferSubData(
                buffer: root::dmGraphics::HVertexBuffer,
                offset: u32,
                size: u32,
                data: *const ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics22GetMaxElementsVerticesEPv"]
            pub fn GetMaxElementsVertices(context: root::dmGraphics::HContext) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics14NewIndexBufferEPvjPKvNS_11BufferUsageE"]
            pub fn NewIndexBuffer(
                context: root::dmGraphics::HContext,
                size: u32,
                data: *const ::std::os::raw::c_void,
                buffer_usage: root::dmGraphics::BufferUsage,
            ) -> root::dmGraphics::HIndexBuffer;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics17DeleteIndexBufferEm"]
            pub fn DeleteIndexBuffer(buffer: root::dmGraphics::HIndexBuffer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics18SetIndexBufferDataEmjPKvNS_11BufferUsageE"]
            pub fn SetIndexBufferData(
                buffer: root::dmGraphics::HIndexBuffer,
                size: u32,
                data: *const ::std::os::raw::c_void,
                buffer_usage: root::dmGraphics::BufferUsage,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics21SetIndexBufferSubDataEmjjPKv"]
            pub fn SetIndexBufferSubData(
                buffer: root::dmGraphics::HIndexBuffer,
                offset: u32,
                size: u32,
                data: *const ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics28IsIndexBufferFormatSupportedEPvNS_17IndexBufferFormatE"]
            pub fn IsIndexBufferFormatSupported(
                context: root::dmGraphics::HContext,
                format: root::dmGraphics::IndexBufferFormat,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics21GetMaxElementsIndicesEPv"]
            pub fn GetMaxElementsIndices(context: root::dmGraphics::HContext) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics20IsExtensionSupportedEPvPKc"]
            pub fn IsExtensionSupported(
                context: root::dmGraphics::HContext,
                extension: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics24IsTextureFormatSupportedEPvNS_13TextureFormatE"]
            pub fn IsTextureFormatSupported(
                context: root::dmGraphics::HContext,
                format: root::dmGraphics::TextureFormat,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics25GetNumSupportedExtensionsEPv"]
            pub fn GetNumSupportedExtensions(context: root::dmGraphics::HContext) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN10dmGraphics21GetSupportedExtensionEPvj"]
            pub fn GetSupportedExtension(
                context: root::dmGraphics::HContext,
                index: u32,
            ) -> *const ::std::os::raw::c_char;
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dmHashTable<KEY, T> {
        pub m_HashTable: *mut u32,
        pub m_HashTableSize: u32,
        pub m_InitialEntries: *mut root::dmHashTable_Entry<KEY, T>,
        pub m_InitialEntriesNextFree: *mut root::dmHashTable_Entry<KEY, T>,
        pub m_InitialEntriesEnd: *mut root::dmHashTable_Entry<KEY, T>,
        pub m_FreeEntries: u32,
        pub m_Count: u32,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub const dmHashTable_STATE_FLAGS_STATE_DEFAULT: root::dmHashTable_STATE_FLAGS = 0;
    pub const dmHashTable_STATE_FLAGS_STATE_USER_ALLOCATED: root::dmHashTable_STATE_FLAGS = 0;
    pub type dmHashTable_STATE_FLAGS = i32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dmHashTable_Entry<KEY, T> {
        pub m_Key: KEY,
        pub m_Value: T,
        pub m_Next: u32,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dmHashTable_Iterator<KEY, T> {
        pub m_Table: *mut root::dmHashTable<KEY, T>,
        pub m_EntryPtr: *mut root::dmHashTable_Entry<KEY, T>,
        pub m_Entry: u32,
        pub m_BucketIndex: u32,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    impl<KEY, T> dmHashTable<KEY, T> {
        #[inline]
        pub fn m_State(&self) -> u16 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_m_State(&mut self, val: u16) {
            unsafe {
                let val: u16 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(m_State: u16) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let m_State: u16 = unsafe { ::std::mem::transmute(m_State) };
                m_State as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dmHashTable16<T> {
        pub _base: root::dmHashTable<u16, T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dmHashTable32<T> {
        pub _base: root::dmHashTable<u32, T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dmHashTable64<T> {
        pub _base: root::dmHashTable<u64, T>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<__va_list_tag>(),
            24usize,
            concat!("Size of: ", stringify!(__va_list_tag))
        );
        assert_eq!(
            ::std::mem::align_of::<__va_list_tag>(),
            8usize,
            concat!("Alignment of ", stringify!(__va_list_tag))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_dmArray_open0_PollFD_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::dmArray<root::dmFileDescriptor::PollFD>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::dmArray<root::dmFileDescriptor::PollFD>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::dmArray<root::dmFileDescriptor::PollFD>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::dmArray<root::dmFileDescriptor::PollFD>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_dmArray_open0_uint8_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::dmArray<u8>>(),
            32usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::dmArray<u8>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::dmArray<u8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::dmArray<u8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_dmHashTable64_open0_ptr_void_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::dmHashTable64<*mut ::std::os::raw::c_void>>(),
            56usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::dmHashTable64<*mut ::std::os::raw::c_void>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::dmHashTable64<*mut ::std::os::raw::c_void>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::dmHashTable64<*mut ::std::os::raw::c_void>)
            )
        );
    }
}
